//+------------------------------------------------------------------+
//|      TickPhysics_Crypto_SelfHealing_Crossover_EA_v5_9            |
//|    MA Crossover + Complete Physics Filters + Self-Healing        |
//|    Version 5.8 - GLOBAL BUFFER SYNCHRONIZATION FIX               |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, QuanAlpha"
#property version   "5.9"
#property strict

#include <Trade\Trade.mqh>

//============================= VERSION TRACKING =========================//
string EA_VERSION = "5.9_ExitRelationshipFix";
string EA_NAME = "TickPhysics_Crossover_Complete";

//============================= v5.8 CHANGELOG ===========================//
// CRITICAL FIXES FROM v5.7:
// 1. âœ… FIXED: MA buffers now GLOBAL instead of function-local
//    - OLD: Created inside each function (WRONG - synchronization issues!)
//    - NEW: Global arrays updated once per bar (CORRECT)
// 2. âœ… NEW: UpdateMABuffers() - Single source of truth for MA values
//    - Called once per bar in OnTick()
//    - All functions now reference same global buffer data
// 3. âœ… NEW: DrawMALines() - Proper MA visualization on chart
//    - Uses global buffers for consistency
// 4. âœ… BENEFIT: Eliminates close/reverse entry timing issues
//    - Exit and entry logic now see IDENTICAL MA values
//    - No more race conditions between CopyBuffer() calls
//========================================================================//

//============================= CSV LOGGING ==============================//
input group "=== CSV LOGGING (Self-Healing) ==="
input bool InpEnableSignalLog = true;
input bool InpEnableTradeLog = true;
input string InpSignalLogFile = "TP_Crypto_Signals_Cross_v5_9.csv";
input string InpTradeLogFile = "TP_Crypto_Trades_Cross_v5_9.csv";

//============================= SELF-LEARNING ============================//
input group "=== Self-Learning System (v5.8) ==="
input bool InpEnableLearning = true;
input string InpLearningFile = "TP_Learning_Cross_v5_9.json";

//============================= INDICATOR SETTINGS =======================//
input group "=== TickPhysics Indicator ==="
input string InpIndicatorName = "TickPhysics_Crypto_Indicator_v2_1";

//============================= MA CROSSOVER BASELINE ====================//
input group "=== MA Crossover Baseline (Deterministic Entry/Exit) ==="
input bool InpUseMAEntry = true;              // Use MA crossover for entry
input int InpMAFast_Entry = 10;               // Fast MA for entry
input int InpMASlow_Entry = 30;               // Slow MA for entry
input bool InpUseMAExit = true;               // Use MA crossover for exit
input int InpMAFast_Exit = 10;                // Fast MA for exit
input int InpMASlow_Exit = 25;                // Slow MA for exit
input ENUM_MA_METHOD InpMAMethod = MODE_EMA;  // MA calculation method
input ENUM_APPLIED_PRICE InpMAPrice = PRICE_CLOSE; // MA applied price

//============================= RISK MANAGEMENT ==========================//
input group "=== Risk Management (v5.0 SAFE DEFAULTS) ==="
input double InpRiskPerTradePercent = 2.0;    // Risk per trade (% of equity)
input double InpStopLossPercent = 3.0;        // Stop Loss (% of PRICE)
input double InpTakeProfitPercent = 2.0;      // Take Profit (% of PRICE)
input double InpMoveToBEAtPercent = 1.0;      // Move to BE at (% profit)
input int InpMaxPositions = 1;
input int InpMaxConsecutiveLosses = 3;

//============================= ENTRY FILTERS ============================//
input group "=== Entry Filters (Self-Optimizing) ==="
input double InpMinTrendQuality = 70.0;
input double InpMinConfluence = 60.0;
input double InpMinMomentum = 50.0;
input bool InpRequireGreenZone = false;
input bool InpTradeOnlyNormalRegime = false;
input int InpDisallowAfterDivergence = 5;
input double InpMaxSpread = 500.0;            // Max spread

//============================= ENTROPY FILTER ===========================//
input group "=== Entropy Filter (Chaos Detection) ==="
input bool InpUseEntropyFilter = false;       // Enable chaos detection
input double InpMaxEntropy = 2.5;             // Max allowed entropy

//============================= ADAPTIVE SL/TP ===========================//
input group "=== Adaptive SL/TP (ATR-based) ==="
input bool InpUseAdaptiveSLTP = false;        // ATR-based adjustment
input double InpATRMultiplierSL = 2.0;        // ATR multiplier for SL
input double InpATRMultiplierTP = 4.0;        // ATR multiplier for TP

//============================= DAILY GOVERNANCE =========================//
input group "=== Daily Governance ==="
input double InpDailyProfitTarget = 10.0;
input double InpDailyDrawdownLimit = 10.0;
input bool InpPauseOnLimits = false;

//============================= SESSION TIMES ============================//
input group "=== Trading Hours ==="
input bool InpUseSessionFilter = false;
input string InpSessionStart = "00:00";
input string InpSessionEnd = "23:59";

//============================= PHYSICS & SELF-HEALING ===================//
input group "=== Physics & Self-Healing (Toggle for Controlled QA) ==="
input bool InpUsePhysics = false;             // Enable physics filters
input bool InpUseSelfHealing = false;         // Enable self-healing optimization
input bool InpUseTickPhysicsIndicator = false; // Use TickPhysics indicator signals

//============================= CHART DISPLAY ============================//
input group "=== Chart Display ==="
input bool InpShowMALines = true;             // Show MA lines on chart
input color InpColorFastEntry = clrBlue;      // Fast Entry MA color
input color InpColorSlowEntry = clrYellow;    // Slow Entry MA color
input color InpColorExit = clrWhite;          // Exit MA color
input int InpMALineWidth = 2;                 // MA line width

//============================= DEBUG MODE (v5.8) ========================//
input group "=== Debug Mode (v5.8 - Buffer Synchronization) ==="
input bool InpEnableDebug = true;             // Enable debug logging

//============================= GLOBAL VARIABLES =========================//
CTrade trade;
int indicatorHandle = INVALID_HANDLE;
datetime lastBarTime = 0;
datetime lastSignalLogTime = 0;

// MA handles for baseline crossover
int maFastEntry_Handle = INVALID_HANDLE;
int maSlowEntry_Handle = INVALID_HANDLE;
int maFastExit_Handle = INVALID_HANDLE;
int maSlowExit_Handle = INVALID_HANDLE;

// âœ… v5.8: GLOBAL MA BUFFERS (synchronized across all functions)
double g_maFastEntry[];   // Global buffer for Fast Entry MA
double g_maSlowEntry[];   // Global buffer for Slow Entry MA
double g_maFastExit[];    // Global buffer for Fast Exit MA
double g_maSlowExit[];    // Global buffer for Slow Exit MA

// Chart window for MA display
int chartWindow = 0;

// Daily tracking
double dailyStartBalance = 0;
int dailyTradeCount = 0;
int consecutiveLosses = 0;
bool dailyPaused = false;
datetime lastDayCheck = 0;

// CSV handles
int signalLogHandle = INVALID_HANDLE;
int tradeLogHandle = INVALID_HANDLE;

// Watchdog
datetime lastTickTime = 0;

// Track last signal to prevent duplicate entries
static int lastSignalProcessed = 0;
static datetime lastSignalTime = 0;

//============================= v5.0: TRADE TRACKER =======================//
struct TradeTracker
{
   ulong ticket;
   datetime openTime;
   double openPrice;
   double sl;
   double tp;
   double lots;
   ENUM_ORDER_TYPE type;
   // Entry conditions
   double entryQuality;
   double entryConfluence;
   double entryZone;
   double entryRegime;
   double entryEntropy;
   double entryMAFast;
   double entryMASlow;
   double entrySpread;
   // MFE/MAE tracking
   double mfe;
   double mae;
};

TradeTracker currentTrades[];

//============================= v5.0: LEARNING STRUCTURE =================//
struct LearningParameters
{
   double MinTrendQuality;
   double MinConfluence;
   double MinMomentum;
   double StopLossPercent;
   double TakeProfitPercent;
   double RiskPerTradePercent;
   
   int totalTrades;
   double winRate;
   double profitFactor;
   double sharpeRatio;
   double maxDrawdown;
   double avgWin;
   double avgLoss;
   double avgRRatio;
   
   string adjustQuality;
   string adjustConfluence;
   string adjustSL;
   string adjustTP;
   string adjustRisk;
   string reason;
   
   datetime lastUpdate;
   string version;
   int learningCycle;
};

LearningParameters learningData;

// Indicator buffer indices
#define BUFFER_SPEED 0
#define BUFFER_ACCEL 1
#define BUFFER_ACCEL_COLOR 2
#define BUFFER_MOMENTUM 3
#define BUFFER_QUALITY 4
#define BUFFER_QUALITY_COLOR 5
#define BUFFER_DISTANCE_ROC 6
#define BUFFER_JERK 7
#define BUFFER_HIGH_THRESHOLD 8
#define BUFFER_LOW_THRESHOLD 9
#define BUFFER_ZERO_LINE 10
#define BUFFER_QUALITY_GLOW 11
#define BUFFER_MOM_SPIKE 12
#define BUFFER_MOM_SPIKE_COLOR 13
#define BUFFER_CONFLUENCE 14
#define BUFFER_CONFLUENCE_COLOR 15
#define BUFFER_VOL_REGIME 16
#define BUFFER_VOL_REGIME_COLOR 17
#define BUFFER_DIVERGENCE 18
#define BUFFER_DIVERGENCE_COLOR 19
#define BUFFER_TRADING_ZONE 20
#define BUFFER_ZONE_COLOR 21
#define BUFFER_ENTROPY 22

//============================= CHUNK 2: HELPER FUNCTIONS ================//

//========================================================================//
//===================== v5.7: HELPER FUNCTIONS ===========================//
//========================================================================//

// Returns the OPPOSITE order type
ENUM_ORDER_TYPE GetOppositeOrderType(ENUM_ORDER_TYPE orderType)
{
   return (orderType == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
}

// Checks if there's an open position in the specified direction
bool HasOpenPositionInDirection(ENUM_ORDER_TYPE orderType)
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      // Robust: select the position context by ticket before accessing its properties
      if(!PositionSelectByTicket(ticket))
         continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;

      ENUM_ORDER_TYPE posType = (ENUM_ORDER_TYPE)PositionGetInteger(POSITION_TYPE);
      if(posType == orderType)
         return true;
   }
   return false;
}

//========================================================================//
//=================== v5.8: UPDATE MA BUFFERS (NEW) ======================//
//========================================================================//
// âœ… v5.8: CRITICAL NEW FUNCTION
// Updates all global MA buffers once per bar
// This ensures ALL functions use synchronized MA data
//========================================================================//

bool UpdateMABuffers()
{
   if(InpEnableDebug)
      Print("ğŸ”„ DEBUG: UpdateMABuffers() called - Syncing global buffers");
   
   // Set arrays as time series (index 0 = most recent)
   ArraySetAsSeries(g_maFastEntry, true);
   ArraySetAsSeries(g_maSlowEntry, true);
   ArraySetAsSeries(g_maFastExit, true);
   ArraySetAsSeries(g_maSlowExit, true);
   
   // Copy Entry MA buffers (need 3 bars for crossover detection)
   if(CopyBuffer(maFastEntry_Handle, 0, 0, 3, g_maFastEntry) < 3)
   {
      if(InpEnableDebug)
         Print("âŒ DEBUG: Failed to copy Fast Entry MA buffer");
      return false;
   }
   
   if(CopyBuffer(maSlowEntry_Handle, 0, 0, 3, g_maSlowEntry) < 3)
   {
      if(InpEnableDebug)
         Print("âŒ DEBUG: Failed to copy Slow Entry MA buffer");
      return false;
   }
   
   // Copy Exit MA buffers (if enabled)
   if(InpUseMAExit)
   {
      if(CopyBuffer(maFastExit_Handle, 0, 0, 3, g_maFastExit) < 3)
      {
         if(InpEnableDebug)
            Print("âŒ DEBUG: Failed to copy Fast Exit MA buffer");
         return false;
      }
      
      if(CopyBuffer(maSlowExit_Handle, 0, 0, 3, g_maSlowExit) < 3)
      {
         if(InpEnableDebug)
            Print("âŒ DEBUG: Failed to copy Slow Exit MA buffer");
         return false;
      }
   }
   
   if(InpEnableDebug)
   {
      Print("âœ… DEBUG: MA Buffers updated successfully:");
      Print("   Entry Fast[0]=", g_maFastEntry[0], " | Slow[0]=", g_maSlowEntry[0]);
      if(InpUseMAExit)
         Print("   Exit Fast[0]=", g_maFastExit[0], " | Slow[0]=", g_maSlowExit[0]);
   }
   
   return true;
}

//========================================================================//
//=================== v5.8: IMPROVED MA SIGNAL (USES GLOBAL BUFFERS) ====//
//========================================================================//
// âœ… v5.8: Now uses GLOBAL buffers instead of creating local ones
// Returns (1=BUY when Fast>Slow, -1=SELL when Fast<Slow, 0=NO_CROSSOVER)
//========================================================================//

int GetMACrossoverSignal()
{
   if(!InpUseMAEntry)
      return 0;
   
   if(InpEnableDebug)
      Print("ğŸ” DEBUG: GetMACrossoverSignal() - Using global buffers");
   
   // âœ… v5.8: Use global buffers (already updated in OnTick)
   if(InpEnableDebug)
   {
      Print("ğŸ“Š DEBUG: MA VALUES (bar[1]=prev, bar[0]=current):");
      Print("   Fast[1]=" , g_maFastEntry[1], " | Fast[0]=" , g_maFastEntry[0]);
      Print("   Slow[1]=" , g_maSlowEntry[1], " | Slow[0]=" , g_maSlowEntry[0]);
   }
   
   // âœ… BULLISH CROSSOVER: Fast crosses ABOVE Slow (entering bar 0)
   bool bullishCross = (g_maFastEntry[1] < g_maSlowEntry[1] && g_maFastEntry[0] > g_maSlowEntry[0]);
   
   if(bullishCross)
   {
      Print("ğŸŸ¢ BULLISH CROSSOVER DETECTED!");
      Print("   Previous bar: Fast=", g_maFastEntry[1], " vs Slow=", g_maSlowEntry[1], " (Fastâ‰¤Slow)");
      Print("   Current bar:  Fast=", g_maFastEntry[0], " vs Slow=", g_maSlowEntry[0], " (Fast>Slow)");
      return 1;  // BUY signal
   }
   
   // âŒ BEARISH CROSSOVER: Fast crosses BELOW Slow (entering bar 0)
   bool bearishCross = (g_maFastEntry[1] >= g_maSlowEntry[1] && g_maFastEntry[0] < g_maSlowEntry[0]);
   
   if(bearishCross)
   {
      Print("ğŸ”´ BEARISH CROSSOVER DETECTED!");
      Print("   Previous bar: Fast=", g_maFastEntry[1], " vs Slow=", g_maSlowEntry[1], " (Fastâ‰¥Slow)");
      Print("   Current bar:  Fast=", g_maFastEntry[0], " vs Slow=", g_maSlowEntry[0], " (Fast<Slow)");
      return -1;  // SELL signal
   }
   
   if(InpEnableDebug)
      Print("âšª DEBUG: No crossover detected this bar");
   
   return 0;
}

//========================================================================//
//=================== v5.8: EXIT SIGNAL (USES GLOBAL BUFFERS) ===========//
//========================================================================//
// âœ… v5.8: Now uses GLOBAL buffers instead of creating local ones
// Returns: ORDER_TYPE_BUY to close BUY positions, ORDER_TYPE_SELL to close SELL
// Returns: -1 if no exit signal
//========================================================================//

int GetPositionTypeToClose()
{
   if(!InpUseMAExit)
      return -1;  // No exit signal
   
   // âœ… v5.9 FIX: Check CURRENT MA RELATIONSHIP, not just crossovers
   // If Fast < Slow NOW, close BUY positions (bullish ended)
   // If Fast > Slow NOW, close SELL positions (bearish ended)
   
   // Check what positions we currently have
   bool hasBuyPosition = HasOpenPositionInDirection(ORDER_TYPE_BUY);
   bool hasSellPosition = HasOpenPositionInDirection(ORDER_TYPE_SELL);
   
   // If we have a BUY and Fast is now below Slow, close it
   if(hasBuyPosition && g_maFastExit[0] < g_maSlowExit[0])
   {
      Print("ğŸšª EXIT SIGNAL: Fast<Slow - Close BUY positions");
      return ORDER_TYPE_BUY;
   }
   
   // If we have a SELL and Fast is now above Slow, close it
   if(hasSellPosition && g_maFastExit[0] > g_maSlowExit[0])
   {
      Print("ğŸšª EXIT SIGNAL: Fast>Slow - Close SELL positions");
      return ORDER_TYPE_SELL;
   }
   
   return -1;  // No exit signal
}

//========================================================================//
//=================== v5.7: MANAGE POSITIONS (FIXED) ====================//
//========================================================================//
// âœ… v5.7: Exit logic correctly closes SAME type positions
// âœ… v5.8: Now uses global buffers for consistency
//========================================================================//

void ManagePositions()
{
   if(InpEnableDebug)
      Print("DEBUG: ManagePositions() START");

   int exitSignal = GetPositionTypeToClose();

   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      // Select position by ticket to ensure PositionGet* calls refer to this position
      if(!PositionSelectByTicket(ticket))
         continue;

      if(PositionGetString(POSITION_SYMBOL) != _Symbol)
         continue;

      ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)PositionGetInteger(POSITION_TYPE);

      // Close position if exit signal matches this position type
      if(exitSignal == (int)orderType)
      {
         if(trade.PositionClose(ticket))
         {
            Print("Position closed on MA exit signal: #", ticket);
            LogTradeClose(ticket, "MA_Exit_Signal");
            if(InpEnableDebug)
               Print("   Position #", ticket, " closed successfully");
         }
         continue;
      }

      // Move to breakeven logic
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentPrice = (orderType == ORDER_TYPE_BUY) ? 
         SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      double profitPercent = 0;
      if(orderType == ORDER_TYPE_BUY)
         profitPercent = ((currentPrice - openPrice) / openPrice) * 100.0;
      else
         profitPercent = ((openPrice - currentPrice) / openPrice) * 100.0;

      if(profitPercent >= InpMoveToBEAtPercent)
      {
         bool needUpdate = false;

         if(orderType == ORDER_TYPE_BUY && currentSL < openPrice)
            needUpdate = true;
         else if(orderType == ORDER_TYPE_SELL && currentSL > openPrice)
            needUpdate = true;

         if(needUpdate)
         {
            if(trade.PositionModify(ticket, openPrice, PositionGetDouble(POSITION_TP)))
            {
               Print("Moved to breakeven: #", ticket);
            }
         }
      }

      UpdateMFEMAE();
   }

   if(InpEnableDebug)
      Print("DEBUG: ManagePositions() END");
}

//========================================================================//
//=================== COUNT POSITIONS ====================================//
//========================================================================//

int CountPositions()
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket))
         continue;
      if(PositionGetString(POSITION_SYMBOL) == _Symbol)
         count++;
   }
   return count;
}

//========================================================================

//========================================================================//
//=================== CHECK DAILY RESET ==================================//
//========================================================================//

void CheckDailyReset()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   if(timeStruct.day != lastDayCheck)
   {
      lastDayCheck = timeStruct.day;
      dailyStartBalance = AccountInfoDouble(ACCOUNT_EQUITY);
      dailyTradeCount = 0;
      dailyPaused = false;
      
      Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
      Print("ğŸ“… NEW TRADING DAY - Daily stats reset");
      Print("   Starting balance: ", dailyStartBalance);
      Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   }
   
   if(InpPauseOnLimits && !dailyPaused)
   {
      double pnl = GetDailyPnL();
      
      if(pnl >= InpDailyProfitTarget)
      {
         Print("âœ… Daily profit target reached: ", pnl, "%");
         dailyPaused = true;
      }
      
      if(pnl <= -InpDailyDrawdownLimit)
      {
         Print("â›” Daily drawdown limit reached: ", pnl, "%");
         dailyPaused = true;
      }
   }
}

//========================================================================//
//=================== CHECK SESSION ======================================//
//========================================================================//

bool IsWithinSession()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   
   string startParts[];
   string endParts[];
   StringSplit(InpSessionStart, ':', startParts);
   StringSplit(InpSessionEnd, ':', endParts);
   
   int startMinutes = (int)StringToInteger(startParts[0]) * 60 + (int)StringToInteger(startParts[1]);
   int endMinutes = (int)StringToInteger(endParts[0]) * 60 + (int)StringToInteger(endParts[1]);
   
   if(startMinutes <= endMinutes)
      return (currentMinutes >= startMinutes && currentMinutes <= endMinutes);
   else
      return (currentMinutes >= startMinutes || currentMinutes <= endMinutes);
}

//============================= CHUNK 5: LOGGING FUNCTIONS ===============//

//========================================================================//
//=================== v5.0: LOG TRADE CLOSE ==============================//
//========================================================================//

void LogTradeClose(ulong ticket, string exitReason)
{
   int trackerIndex = -1;
   for(int i = 0; i < ArraySize(currentTrades); i++)
   {
      if(currentTrades[i].ticket == ticket)
      {
         trackerIndex = i;
         break;
      }
   }
   
   if(trackerIndex < 0)
   {
      Print("WARNING: No tracker found for closed trade: ", ticket);
      return;
   }
   
   if(!HistorySelectByPosition(ticket))
   {
      Print("ERROR: Cannot find trade in history: ", ticket);
      return;
   }
   
   int totalDeals = HistoryDealsTotal();
   ulong closeDeal = 0;
   double profit = 0;
   double exitPrice = 0;
   datetime exitTime = 0;
   
   for(int i = totalDeals - 1; i >= 0; i--)
   {
      closeDeal = HistoryDealGetTicket(i);
      if(HistoryDealGetInteger(closeDeal, DEAL_POSITION_ID) == ticket &&
         HistoryDealGetInteger(closeDeal, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         profit = HistoryDealGetDouble(closeDeal, DEAL_PROFIT);
         exitPrice = HistoryDealGetDouble(closeDeal, DEAL_PRICE);
         exitTime = (datetime)HistoryDealGetInteger(closeDeal, DEAL_TIME);
         break;
      }
   }
   
   double exitQuality = 0, exitConfluence = 0;
   if(InpUsePhysics && InpUseTickPhysicsIndicator)
   {
      double qBuf[1], cBuf[1];
      if(CopyBuffer(indicatorHandle, BUFFER_QUALITY, 0, 1, qBuf) > 0) exitQuality = qBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_CONFLUENCE, 0, 1, cBuf) > 0) exitConfluence = cBuf[0];
   }
   
   double profitPercent = (profit / AccountInfoDouble(ACCOUNT_EQUITY)) * 100.0;
   
   double pips = 0;
   if(currentTrades[trackerIndex].type == ORDER_TYPE_BUY)
      pips = (exitPrice - currentTrades[trackerIndex].openPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   else
      pips = (currentTrades[trackerIndex].openPrice - exitPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   
   int holdTimeBars = (int)((exitTime - currentTrades[trackerIndex].openTime) / PeriodSeconds(_Period));
   
   double mfePercent = 0, maePercent = 0, mfePips = 0, maePips = 0;
   if(currentTrades[trackerIndex].type == ORDER_TYPE_BUY)
   {
      mfePercent = ((currentTrades[trackerIndex].mfe - currentTrades[trackerIndex].openPrice) / currentTrades[trackerIndex].openPrice) * 100.0;
      maePercent = ((currentTrades[trackerIndex].mae - currentTrades[trackerIndex].openPrice) / currentTrades[trackerIndex].openPrice) * 100.0;
      mfePips = (currentTrades[trackerIndex].mfe - currentTrades[trackerIndex].openPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
      maePips = (currentTrades[trackerIndex].mae - currentTrades[trackerIndex].openPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   }
   else
   {
      mfePercent = ((currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mfe) / currentTrades[trackerIndex].openPrice) * 100.0;
      maePercent = ((currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mae) / currentTrades[trackerIndex].openPrice) * 100.0;
      mfePips = (currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mfe) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
      maePips = (currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mae) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   }
   
   double riskPercent = InpRiskPerTradePercent;
   double rRatio = (riskPercent != 0) ? (profitPercent / riskPercent) : 0;
   
   MqlDateTime entryTime, closeTime;
   TimeToStruct(currentTrades[trackerIndex].openTime, entryTime);
   TimeToStruct(exitTime, closeTime);
   
   int handle = FileOpen(InpTradeLogFile, FILE_READ|FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(handle == INVALID_HANDLE)
   {
      Print("ERROR: Could not open trade log file");
      return;
   }
   
   FileSeek(handle, 0, SEEK_END);
   
   FileWrite(handle,
      TimeToString(currentTrades[trackerIndex].openTime), ticket, _Symbol, "CLOSE", 
      (currentTrades[trackerIndex].type == ORDER_TYPE_BUY) ? "BUY" : "SELL",
      currentTrades[trackerIndex].lots, currentTrades[trackerIndex].openPrice, currentTrades[trackerIndex].sl, currentTrades[trackerIndex].tp,
      currentTrades[trackerIndex].entryQuality, currentTrades[trackerIndex].entryConfluence, currentTrades[trackerIndex].entryZone, currentTrades[trackerIndex].entryRegime, currentTrades[trackerIndex].entryEntropy,
      currentTrades[trackerIndex].entryMAFast, currentTrades[trackerIndex].entryMASlow, currentTrades[trackerIndex].entrySpread,
      exitPrice, exitReason, profit, profitPercent, pips,
      exitQuality, exitConfluence, holdTimeBars,
      currentTrades[trackerIndex].mfe, currentTrades[trackerIndex].mae, mfePercent, maePercent, mfePips, maePips,
      riskPercent, rRatio,
      entryTime.hour, entryTime.day_of_week, closeTime.hour
   );
   
   FileClose(handle);
   
   // Update consecutive losses counter
   if(profit < 0)
      consecutiveLosses++;
   else
      consecutiveLosses = 0;
   
   // Remove from tracker
   int size = ArraySize(currentTrades);
   for(int i = trackerIndex; i < size - 1; i++)
   {
      currentTrades[i] = currentTrades[i + 1];
   }
   ArrayResize(currentTrades, size - 1);
}

//========================================================================//
//=================== LOG SIGNAL =========================================//
//========================================================================//

void LogSignal(int signal, double quality, double confluence, double momentum, 
               double tradingZone, double volRegime, double entropy,
               bool physicsPass, string rejectReason)
{
   // âœ… v5.8: Use global MA buffers
   double maFastEntry = g_maFastEntry[0];
   double maSlowEntry = g_maSlowEntry[0];
   double maFastExit = InpUseMAExit ? g_maFastExit[0] : 0;
   double maSlowExit = InpUseMAExit ? g_maSlowExit[0] : 0;
   
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double spread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   int handle = FileOpen(InpSignalLogFile, FILE_READ|FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(handle == INVALID_HANDLE)
   {
      Print("ERROR: Could not open signal log file");
      return;
   }
   
   FileSeek(handle, 0, SEEK_END);
   
   string signalType = (signal == 1) ? "BULLISH_CROSS" : (signal == -1) ? "BEARISH_CROSS" : "NO_SIGNAL";
   
   FileWrite(handle,
      TimeToString(TimeCurrent()), signal, signalType,
      maFastEntry, maSlowEntry, maFastExit, maSlowExit,
      quality, confluence, momentum, tradingZone, volRegime, entropy,
      currentPrice, spread, timeStruct.hour, timeStruct.day_of_week,
      (InpUsePhysics ? "YES" : "NO"), (physicsPass ? "PASS" : "REJECT"), rejectReason
   );
   
   FileClose(handle);
}

//============================= CHUNK 3: PHYSICS & TRADING ===============//

//========================================================================//
//=================== CHECK PHYSICS FILTERS ==============================//
//========================================================================//

bool CheckPhysicsFilters(int signal, double quality, double confluence, 
                         double tradingZone, double volRegime, double entropy,
                         string &rejectReason)
{
   if(!InpUsePhysics || !InpUseTickPhysicsIndicator)
   {
      rejectReason = "N/A_Physics_Disabled";
      return true;
   }
   
   if(quality < InpMinTrendQuality)
   {
      rejectReason = StringFormat("Quality_Too_Low_%.1f<%.1f", quality, InpMinTrendQuality);
      return false;
   }
   
   if(confluence < InpMinConfluence)
   {
      rejectReason = StringFormat("Confluence_Too_Low_%.1f<%.1f", confluence, InpMinConfluence);
      return false;
   }
   
   if(InpRequireGreenZone)
   {
      bool isGreenZone = (signal == 1 && tradingZone == 0) || (signal == -1 && tradingZone == 1);
      if(!isGreenZone)
      {
         rejectReason = "Not_In_Green_Zone";
         return false;
      }
   }
   
   if(InpTradeOnlyNormalRegime && volRegime != 0)
   {
      rejectReason = StringFormat("Regime_Not_Normal_%.0f", volRegime);
      return false;
   }
   
   if(InpUseEntropyFilter && entropy > InpMaxEntropy)
   {
      rejectReason = StringFormat("Entropy_Too_High_%.2f>%.2f", entropy, InpMaxEntropy);
      return false;
   }
   
   double spread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   if(spread > InpMaxSpread)
   {
      rejectReason = StringFormat("Spread_Too_Wide_%.1f>%.1f", spread, InpMaxSpread);
      return false;
   }
   
   rejectReason = "All_Filters_Pass";
   return true;
}

//========================================================================//
//=================== OPEN POSITION ======================================//
//========================================================================//

bool OpenPosition(ENUM_ORDER_TYPE orderType)
{
   double currentPrice = (orderType == ORDER_TYPE_BUY) ? 
      SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   double slDistance = currentPrice * (InpStopLossPercent / 100.0);
   double tpDistance = currentPrice * (InpTakeProfitPercent / 100.0);
   
   double sl = 0, tp = 0;
   if(orderType == ORDER_TYPE_BUY)
   {
      sl = currentPrice - slDistance;
      tp = currentPrice + tpDistance;
   }
   else
   {
      sl = currentPrice + slDistance;
      tp = currentPrice - tpDistance;
   }
   
   double riskAmount = AccountInfoDouble(ACCOUNT_EQUITY) * (InpRiskPerTradePercent / 100.0);
   double lots = riskAmount / (slDistance / SymbolInfoDouble(_Symbol, SYMBOL_POINT) * SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE));
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lots = MathMax(minLot, MathMin(maxLot, MathRound(lots / lotStep) * lotStep));
   
   if(InpEnableDebug)
   {
      Print("ğŸ¯ DEBUG: Opening position:");
      Print("   Type: ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"));
      Print("   Price: ", currentPrice);
      Print("   SL: ", sl, " (", slDistance, " distance)");
      Print("   TP: ", tp, " (", tpDistance, " distance)");
      Print("   Lots: ", lots);
   }
   
   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(50);
   
   bool result = false;
   if(orderType == ORDER_TYPE_BUY)
      result = trade.Buy(lots, _Symbol, currentPrice, sl, tp, "TickPhysics_v5.8");
   else
      result = trade.Sell(lots, _Symbol, currentPrice, sl, tp, "TickPhysics_v5.8");
   
   if(!result)
   {
      Print("âŒ Trade failed: ", trade.ResultRetcode(), " - ", trade.ResultRetcodeDescription());
      return false;
   }
   
   ulong ticket = trade.ResultOrder();
   Print("âœ… Position opened: #", ticket, " | ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"), 
         " | Lots: ", lots, " | Entry: ", currentPrice);
   
   // Track the trade
   int size = ArraySize(currentTrades);
   ArrayResize(currentTrades, size + 1);
   
   currentTrades[size].ticket = ticket;
   currentTrades[size].openTime = TimeCurrent();
   currentTrades[size].openPrice = currentPrice;
   currentTrades[size].sl = sl;
   currentTrades[size].tp = tp;
   currentTrades[size].lots = lots;
   currentTrades[size].type = orderType;
   
   // Store entry conditions using global buffers
   currentTrades[size].entryMAFast = g_maFastEntry[0];
   currentTrades[size].entryMASlow = g_maSlowEntry[0];
   currentTrades[size].entrySpread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   if(InpUsePhysics && InpUseTickPhysicsIndicator)
   {
      double qBuf[1], cBuf[1], zBuf[1], rBuf[1], eBuf[1];
      if(CopyBuffer(indicatorHandle, BUFFER_QUALITY, 0, 1, qBuf) > 0) currentTrades[size].entryQuality = qBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_CONFLUENCE, 0, 1, cBuf) > 0) currentTrades[size].entryConfluence = cBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_TRADING_ZONE, 0, 1, zBuf) > 0) currentTrades[size].entryZone = zBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_VOL_REGIME, 0, 1, rBuf) > 0) currentTrades[size].entryRegime = rBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_ENTROPY, 0, 1, eBuf) > 0) currentTrades[size].entryEntropy = eBuf[0];
   }
   
   currentTrades[size].mfe = currentPrice;
   currentTrades[size].mae = currentPrice;
   
   // Log to file
   if(InpEnableTradeLog)
   {
      int handle = FileOpen(InpTradeLogFile, FILE_READ|FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
      if(handle != INVALID_HANDLE)
      {
         FileSeek(handle, 0, SEEK_END);
         FileWrite(handle,
            TimeToString(TimeCurrent()), ticket, _Symbol, "OPEN",
            (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"),
            lots, currentPrice, sl, tp,
            currentTrades[size].entryQuality, currentTrades[size].entryConfluence,
            currentTrades[size].entryZone, currentTrades[size].entryRegime,
            currentTrades[size].entryEntropy, currentTrades[size].entryMAFast,
            currentTrades[size].entryMASlow, currentTrades[size].entrySpread
         );
         FileClose(handle);
      }
   }
   
   return true;
}

//========================================================================//
//=================== UPDATE MFE/MAE =====================================//
//========================================================================//

void UpdateMFEMAE()
{
   for(int i = 0; i < ArraySize(currentTrades); i++)
   {
      double currentPrice = 0;

      for(int p = 0; p < PositionsTotal(); p++)
      {
         ulong pTicket = PositionGetTicket(p);
         if(pTicket == 0) continue;
         if(pTicket != currentTrades[i].ticket) continue;
         if(!PositionSelectByTicket(pTicket))
            continue;
         currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
         break;
      }

      if(currentPrice == 0) continue;

      if(currentTrades[i].type == ORDER_TYPE_BUY)
      {
         if(currentPrice > currentTrades[i].mfe)
            currentTrades[i].mfe = currentPrice;
         if(currentPrice < currentTrades[i].mae)
            currentTrades[i].mae = currentPrice;
      }
      else
      {
         if(currentPrice < currentTrades[i].mfe)
            currentTrades[i].mfe = currentPrice;
         if(currentPrice > currentTrades[i].mae)
            currentTrades[i].mae = currentPrice;
      }
   }
}

//============================= CHUNK 7: CSV INIT & DISPLAY ==============//

//========================================================================//
//=================== INITIALIZE SIGNAL LOG ==============================//
//========================================================================//

bool InitSignalLog()
{
   signalLogHandle = FileOpen(InpSignalLogFile, FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(signalLogHandle == INVALID_HANDLE)
   {
      Print("Failed to create signal log: ", InpSignalLogFile);
      return false;
   }
   
   FileWrite(signalLogHandle, 
      "Timestamp", "Signal", "SignalType",
      "MA_Fast_Entry", "MA_Slow_Entry", "MA_Fast_Exit", "MA_Slow_Exit",
      "Quality", "Confluence", "Momentum", "TradingZone", "VolRegime", "Entropy",
      "Price", "Spread", "Hour", "DayOfWeek",
      "PhysicsEnabled", "PhysicsPass", "RejectReason"
   );
   
   FileClose(signalLogHandle);
   return true;
}

//========================================================================//
//=================== INITIALIZE TRADE LOG ===============================//
//========================================================================//

bool InitTradeLog()
{
   tradeLogHandle = FileOpen(InpTradeLogFile, FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(tradeLogHandle == INVALID_HANDLE)
   {
      Print("Failed to create trade log: ", InpTradeLogFile);
      return false;
   }
   
   FileWrite(tradeLogHandle,
      "Timestamp", "Ticket", "Symbol", "Action", "Type", 
      "Lots", "EntryPrice", "SL", "TP",
      "EntryQuality", "EntryConfluence", "EntryZone", "EntryRegime", "EntryEntropy",
      "EntryMAFast", "EntryMASlow", "EntrySpread",
      "ExitPrice", "ExitReason", "Profit", "ProfitPercent", "Pips",
      "ExitQuality", "ExitConfluence", "HoldTimeBars",
      "MFE", "MAE", "MFEPercent", "MAEPercent", "MFE_Pips", "MAE_Pips",
      "RiskPercent", "RRatio",
      "EntryHour", "EntryDayOfWeek", "ExitHour"
   );
   
   FileClose(tradeLogHandle);
   return true;
}

//========================================================================//
//=================== v5.8: DRAW MA LINES (NEW) =========================//
//========================================================================//
// âœ… v5.8: NEW FUNCTION - Draw MA lines on chart using global buffers
//========================================================================//

void DrawMALines()
{
   if(!InpShowMALines)
      return;
   
   // Draw Entry MAs
   string nameFastEntry = "MA_Fast_Entry";
   string nameSlowEntry = "MA_Slow_Entry";
   
   ObjectCreate(0, nameFastEntry, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maFastEntry[1], 
                iTime(_Symbol, _Period, 0), g_maFastEntry[0]);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_COLOR, InpColorFastEntry);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_WIDTH, InpMALineWidth);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_RAY_RIGHT, false);
   
   ObjectCreate(0, nameSlowEntry, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maSlowEntry[1], 
                iTime(_Symbol, _Period, 0), g_maSlowEntry[0]);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_COLOR, InpColorSlowEntry);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_WIDTH, InpMALineWidth);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_RAY_RIGHT, false);
   
   // Draw Exit MAs if enabled
   if(InpUseMAExit)
   {
      string nameFastExit = "MA_Fast_Exit";
      string nameSlowExit = "MA_Slow_Exit";
      
      ObjectCreate(0, nameFastExit, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maFastExit[1], 
                   iTime(_Symbol, _Period, 0), g_maFastExit[0]);
      ObjectSetInteger(0, nameFastExit, OBJPROP_COLOR, InpColorExit);
      ObjectSetInteger(0, nameFastExit, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, nameFastExit, OBJPROP_STYLE, STYLE_DOT);
      ObjectSetInteger(0, nameFastExit, OBJPROP_RAY_RIGHT, false);
      
      ObjectCreate(0, nameSlowExit, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maSlowExit[1], 
                   iTime(_Symbol, _Period, 0), g_maSlowExit[0]);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_COLOR, InpColorExit);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_STYLE, STYLE_DASH);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_RAY_RIGHT, false);
   }
}

//========================================================================//
//=================== UPDATE DISPLAY =====================================//
//========================================================================//

void UpdateDisplay(int signal, double quality, double confluence, 
                   double tradingZone, double volRegime, double entropy)
{
   // âœ… v5.8: Use global MA buffers for display
   string maEntryStatus = (g_maFastEntry[0] > g_maSlowEntry[0]) ? "ğŸŸ¢ BULLISH" : "ğŸ”´ BEARISH";
   string maExitStatus = InpUseMAExit ? 
      ((g_maFastExit[0] > g_maSlowExit[0]) ? "ğŸŸ¢ ABOVE" : "ğŸ”´ BELOW") : "N/A";
   
   string modeStr = "";
   if(!InpUsePhysics && !InpUseTickPhysicsIndicator)
      modeStr = "MA Crossover ONLY (Baseline)";
   else if(InpUsePhysics && InpUseTickPhysicsIndicator)
      modeStr = "MA Crossover + Physics Filters";
   else
      modeStr = "Hybrid Mode";
   
   string zoneStr = (tradingZone == 0) ? "ğŸŸ¢ BULL" :
                    (tradingZone == 1) ? "ğŸ”´ BEAR" :
                    (tradingZone == 2) ? "ğŸŸ¡ TRANS" : "âš« AVOID";
   
   string signalStr = (signal == 1) ? "ğŸŸ¢ BUY SIGNAL" :
                      (signal == -1) ? "ğŸ”´ SELL SIGNAL" : "âšª NO SIGNAL";
   
   string filterStatus = (InpUsePhysics) ? "âœ… ON" : "âŒ OFF";
   
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double dailyPnL = GetDailyPnL();
   
   Comment(StringFormat(
      "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
      "â•‘  %s v%s  â•‘\n"
      "â•‘  MODE: %-36s  â•‘\n"
      "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n"
      "â•‘  ğŸ“Š MA CROSSOVER STATUS                         â•‘\n"
      "â•‘  Entry:  %-37s  â•‘\n"
      "â•‘  Exit:   %-37s  â•‘\n"
      "â•‘  Signal: %-37s  â•‘\n"
      "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n"
      "â•‘  âš™ï¸  CONFIGURATION                               â•‘\n"
      "â•‘  Physics Filters:  %-27s  â•‘\n"
      "â•‘  TickPhysics Ind:  %-27s  â•‘\n"
      "â•‘  Entropy Filter:   %-27s  â•‘\n"
      "â•‘  Zone Filter:      %-27s  â•‘\n"
      "â•‘  Regime Filter:    %-27s  â•‘\n"
      "â•‘  Session Filter:   %-27s  â•‘\n"
      "â•‘  Daily Limits:     %-27s  â•‘\n"
      "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n"
      "â•‘  ğŸ’° TRADING STATUS                              â•‘\n"
      "â•‘  Price:           $%-28.2f  â•‘\n"
      "â•‘  Positions:       %-2d / %-2d                    â•‘\n"
      "â•‘  Daily P/L:       %-7.2f%%                     â•‘\n"
      "â•‘  Daily Trades:    %-3d                          â•‘\n"
      "â•‘  Consec Losses:   %-2d                           â•‘\n"
      "â•‘  Status:          %-28s  â•‘\n"
      "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n"
      "â•‘  ğŸ“ˆ PHYSICS METRICS (if enabled)                â•‘\n"
      "â•‘  Quality:    %-6.1f  |  Confluence: %-6.1f    â•‘\n"
      "â•‘  Zone:       %-28s  â•‘\n"
      "â•‘  Entropy:    %-7.2f  %-20s  â•‘\n"
      "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
      EA_NAME, EA_VERSION,
      modeStr,
      maEntryStatus,
      maExitStatus,
      signalStr,
      filterStatus,
      (InpUseTickPhysicsIndicator ? "âœ… ON" : "âŒ OFF"),
      (InpUseEntropyFilter ? "âœ… ON" : "âŒ OFF"),
      (InpRequireGreenZone ? "âœ… ON" : "âŒ OFF"),
      (InpTradeOnlyNormalRegime ? "âœ… ON" : "âŒ OFF"),
      (InpUseSessionFilter ? "âœ… ON" : "âŒ OFF"),
      (InpPauseOnLimits ? "âœ… ON" : "âŒ OFF"),
      currentPrice,
      CountPositions(), InpMaxPositions,
      dailyPnL,
      dailyTradeCount,
      consecutiveLosses,
      (dailyPaused ? "â¸ï¸ PAUSED" : "âœ… ACTIVE"),
      quality, confluence,
      zoneStr,
      entropy, 
      (entropy > InpMaxEntropy ? "(ğŸ”´ CHAOS)" : entropy > InpMaxEntropy * 0.7 ? "(ğŸŸ¡ NOISY)" : "(ğŸŸ¢ CLEAN)")
   ));
}

//============================= CHUNK 8: MAIN EVENT FUNCTIONS ============//

//========================================================================//
//=================== OnInit() ===========================================//
//========================================================================//

int OnInit()
{
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   Print("ğŸš€ Initializing ", EA_NAME, " v", EA_VERSION);
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   
   // Create MA indicators
   maFastEntry_Handle = iMA(_Symbol, _Period, InpMAFast_Entry, 0, InpMAMethod, InpMAPrice);
   maSlowEntry_Handle = iMA(_Symbol, _Period, InpMASlow_Entry, 0, InpMAMethod, InpMAPrice);
   
   if(maFastEntry_Handle == INVALID_HANDLE || maSlowEntry_Handle == INVALID_HANDLE)
   {
      Print("âŒ ERROR: Failed to create Entry MA indicators");
      return INIT_FAILED;
   }
   
   if(InpUseMAExit)
   {
      maFastExit_Handle = iMA(_Symbol, _Period, InpMAFast_Exit, 0, InpMAMethod, InpMAPrice);
      maSlowExit_Handle = iMA(_Symbol, _Period, InpMASlow_Exit, 0, InpMAMethod, InpMAPrice);
      
      if(maFastExit_Handle == INVALID_HANDLE || maSlowExit_Handle == INVALID_HANDLE)
      {
         Print("âŒ ERROR: Failed to create Exit MA indicators");
         return INIT_FAILED;
      }
   }
   
   // âœ… v5.8: Initialize global MA buffer arrays
   ArraySetAsSeries(g_maFastEntry, true);
   ArraySetAsSeries(g_maSlowEntry, true);
   ArraySetAsSeries(g_maFastExit, true);
   ArraySetAsSeries(g_maSlowExit, true);
   
   if(InpUseTickPhysicsIndicator)
   {
      indicatorHandle = iCustom(_Symbol, _Period, InpIndicatorName);
      
      if(indicatorHandle == INVALID_HANDLE)
      {
         Print("âš ï¸ WARNING: TickPhysics indicator not found!");
         Print("   Indicator name: ", InpIndicatorName);
         Print("   Physics filters will be disabled");
      }
      else
      {
         Print("âœ… TickPhysics indicator loaded successfully");
      }
   }
   
   if(InpEnableSignalLog)
   {
      if(!InitSignalLog())
      {
         Print("âŒ ERROR: Failed to initialize signal log");
         return INIT_FAILED;
      }
      Print("âœ… Signal logging initialized");
   }
   
   if(InpEnableTradeLog)
   {
      if(!InitTradeLog())
      {
         Print("âŒ ERROR: Failed to initialize trade log");
         return INIT_FAILED;
      }
      Print("âœ… Trade logging initialized");
   }
   
   dailyStartBalance = AccountInfoDouble(ACCOUNT_EQUITY);
   lastDayCheck = 0;
   
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   Print("ğŸ“‹ EA CONFIGURATION:");
   Print("   Entry MA: ", InpMAFast_Entry, "/", InpMASlow_Entry);
   Print("   Exit MA: ", InpMAFast_Exit, "/", InpMASlow_Exit);
   Print("   Risk: ", InpRiskPerTradePercent, "% | SL: ", InpStopLossPercent, "% | TP: ", InpTakeProfitPercent, "%");
   Print("   Physics: ", (InpUsePhysics ? "ENABLED" : "DISABLED"));
   Print("   Indicator: ", (InpUseTickPhysicsIndicator ? "ENABLED" : "DISABLED"));
   Print("   Max Spread: ", InpMaxSpread, " points");
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   Print("âœ… EA initialized successfully - Ready to trade!");
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   
   return INIT_SUCCEEDED;
}

//========================================================================//
//=================== OnDeinit() =========================================//
//========================================================================//

void OnDeinit(const int reason)
{
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   Print("ğŸ›‘ Shutting down ", EA_NAME, " v", EA_VERSION);
   Print("   Reason: ", reason);
   
   if(maFastEntry_Handle != INVALID_HANDLE) IndicatorRelease(maFastEntry_Handle);
   if(maSlowEntry_Handle != INVALID_HANDLE) IndicatorRelease(maSlowEntry_Handle);
   if(maFastExit_Handle != INVALID_HANDLE) IndicatorRelease(maFastExit_Handle);
   if(maSlowExit_Handle != INVALID_HANDLE) IndicatorRelease(maSlowExit_Handle);
   if(indicatorHandle != INVALID_HANDLE) IndicatorRelease(indicatorHandle);
   
   // Clean up chart objects
   ObjectsDeleteAll(0, "MA_");
   
   Print("   Total daily trades: ", dailyTradeCount);
   Print("   Daily P/L: ", GetDailyPnL(), "%");
   
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   Print("âœ… EA shutdown complete");
   Print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
   
   Comment("");
}

//========================================================================//
//=================== OnTick() - v5.8 WITH GLOBAL BUFFERS ===============//
//========================================================================//
// âœ… v5.8: MA buffers updated ONCE per bar, then shared globally
//========================================================================//

void OnTick()
{
   lastTickTime = TimeCurrent();
   
   datetime currentBarTime = iTime(_Symbol, _Period, 0);
   if(currentBarTime == lastBarTime)
      return;
   lastBarTime = currentBarTime;
   
   CheckDailyReset();
   
   if(dailyPaused)
   {
      Comment("â¸ï¸ EA PAUSED - Daily limits reached\n",
              "Daily P/L: ", DoubleToString(GetDailyPnL(), 2), "%\n",
              "Resets at midnight");
      return;
   }
   
   if(InpUseSessionFilter && !IsWithinSession())
      return;
   
   // ========================================================================
   // âœ… v5.8: STEP 1 - UPDATE GLOBAL MA BUFFERS (ONCE PER BAR)
   // This is the KEY FIX - all functions now use the same synchronized data
   // ========================================================================
   if(!UpdateMABuffers())
   {
      Print("âŒ ERROR: Failed to update MA buffers");
      return;
   }
   
   // ========================================================================
   // STEP 2: Get the current signal (now uses global buffers)
   // ========================================================================
   int signal = GetMACrossoverSignal();
   
   if(InpEnableDebug)
      Print("ğŸ” DEBUG: OnTick() START - Signal=", signal);
   
   double quality = 0.0, confluence = 0.0, momentum = 0.0;
   double tradingZone = 0.0, volRegime = 0.0, entropy = 0.0;
   
   if(InpUsePhysics && InpUseTickPhysicsIndicator)
   {
      double qualityBuf[1], confluenceBuf[1], momentumBuf[1], zoneBuf[1], regimeBuf[1], entropyBuf[1];
      if(CopyBuffer(indicatorHandle, BUFFER_QUALITY, 0, 1, qualityBuf) > 0)
         quality = qualityBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_CONFLUENCE, 0, 1, confluenceBuf) > 0)
         confluence = confluenceBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_MOMENTUM, 0, 1, momentumBuf) > 0)
         momentum = momentumBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_TRADING_ZONE, 0, 1, zoneBuf) > 0)
         tradingZone = zoneBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_VOL_REGIME, 0, 1, regimeBuf) > 0)
         volRegime = regimeBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_ENTROPY, 0, 1, entropyBuf) > 0)
         entropy = entropyBuf[0];
   }
   
   string rejectReason = "";
   bool physicsPass = CheckPhysicsFilters(signal, quality, confluence, tradingZone, 
                                          volRegime, entropy, rejectReason);
   
   if(InpEnableSignalLog && signal != 0)
   {
      LogSignal(signal, quality, confluence, momentum, tradingZone, volRegime, entropy, 
                physicsPass, rejectReason);
   }
   
   // ========================================================================
   // STEP 3: MANAGE POSITIONS FIRST (exits before new entries)
   // ========================================================================
   if(InpEnableDebug)
      Print("ğŸ” DEBUG: Calling ManagePositions()");
   
   ManagePositions();
   
   // ========================================================================
   // STEP 4: After positions managed, attempt entry based on signal
   // ========================================================================
   int currentPositions = CountPositions();
   
   if(InpEnableDebug)
      Print("ğŸ” DEBUG: After ManagePositions() - Positions=", currentPositions);
   
   if(signal != 0)
   {
      ENUM_ORDER_TYPE orderType = (signal == 1) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
      ENUM_ORDER_TYPE oppositeType = GetOppositeOrderType(orderType);
      
      // Check conditions before entry
      bool hasOppositePosition = HasOpenPositionInDirection(oppositeType);
      
      if(InpEnableDebug)
      {
         Print("   Signal Direction: ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"));
         Print("   Has Opposite Position: ", hasOppositePosition ? "YES" : "NO");
         Print("   Current Positions: ", currentPositions, "/", InpMaxPositions);
      }
      
      if(hasOppositePosition)
      {
         if(InpEnableDebug)
            Print("âŒ DEBUG: Entry blocked - Opposite position already open");
      }
      else if(currentPositions >= InpMaxPositions)
      {
         if(InpEnableDebug)
            Print("âŒ DEBUG: Entry blocked - Max positions (", currentPositions, "/", InpMaxPositions, ")");
      }
      else if(consecutiveLosses >= InpMaxConsecutiveLosses)
      {
         if(InpEnableDebug)
            Print("âŒ DEBUG: Entry blocked - Max losses (", consecutiveLosses, "/", InpMaxConsecutiveLosses, ")");
      }
      else if(!physicsPass)
      {
         if(InpEnableDebug)
            Print("âŒ DEBUG: Entry blocked by physics: ", rejectReason);
      }
      else
      {
         if(InpEnableDebug)
            Print("âœ… DEBUG: Opening ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"));
         
         if(OpenPosition(orderType))
         {
            dailyTradeCount++;
         }
      }
   }
   
   // ========================================================================
   // STEP 5: Draw MA lines on chart (using global buffers)
   // ========================================================================
   DrawMALines();
   
   UpdateDisplay(signal, quality, confluence, tradingZone, volRegime, entropy);
}

//========================================================================//
//=================== END OF v5.8 EA =====================================//
//========================================================================//

/*
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                      â•‘
â•‘  TickPhysics EA v5.8 - GLOBAL BUFFER SYNCHRONIZATION FIX             â•‘
â•‘                                                                      â•‘
â•‘  âœ… KEY IMPROVEMENTS FROM v5.7:                                      â•‘
â•‘                                                                      â•‘
â•‘  1. GLOBAL MA BUFFERS (Root Cause Fix)                               â•‘
â•‘     - OLD: Local buffers created in each function                    â•‘
â•‘     - NEW: Global arrays (g_maFastEntry, g_maSlowEntry, etc.)        â•‘
â•‘     - BENEFIT: All functions see IDENTICAL MA values per bar         â•‘
â•‘                                                                      â•‘
â•‘  2. UpdateMABuffers() - Single Source of Truth                       â•‘
â•‘     - Called once per bar in OnTick() before any logic               â•‘
â•‘     - Copies all MA data to global arrays                            â•‘
â•‘     - Eliminates timing issues between CopyBuffer() calls            â•‘
â•‘                                                                      â•‘
â•‘  3. Functions Now Reference Global Buffers                           â•‘
â•‘     - GetMACrossoverSignal() - uses g_maFastEntry[], g_maSlowEntry[] â•‘
â•‘     - GetPositionTypeToClose() - uses g_maFastExit[], g_maSlowExit[] â•‘
â•‘     - UpdateDisplay() - uses all global buffers                      â•‘
â•‘     - LogSignal() - uses all global buffers                          â•‘
â•‘     - DrawMALines() - NEW function using global buffers              â•‘
â•‘                                                                      â•‘
â•‘  4. DrawMALines() - Proper Chart Visualization                       â•‘
â•‘     - Draws MA lines on chart using synchronized global data         â•‘
â•‘     - Entry MAs in solid lines (Fast=Blue, Slow=Yellow)              â•‘
â•‘     - Exit MAs in dashed lines (White)                               â•‘
â•‘                                                                      â•‘
â•‘  WHY THIS FIXES CLOSE/REVERSE ENTRY ISSUES:                          â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â•‘
â•‘  Problem: In v5.7, GetMACrossoverSignal() and                        â•‘
â•‘  GetPositionTypeToClose() each called CopyBuffer() independently.    â•‘
â•‘  On fast-moving bars, they could get DIFFERENT MA values!            â•‘
â•‘                                                                      â•‘
â•‘  Solution: v5.8 calls UpdateMABuffers() ONCE per bar in OnTick().    â•‘
â•‘  Both entry and exit logic now reference the SAME global arrays.     â•‘
â•‘  This ensures perfect synchronization for closeâ†’reverse scenarios.   â•‘
â•‘                                                                      â•‘
â•‘  TESTING CHECKLIST:                                                  â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â•‘
â•‘  âœ… Compile v5.8 (should have 0 errors)                              â•‘
â•‘  âœ… Set InpEnableDebug = true                                        â•‘
â•‘  âœ… Backtest on volatile period with multiple crossovers             â•‘
â•‘  âœ… Verify debug logs show UpdateMABuffers() called first            â•‘
â•‘  âœ… Verify entry/exit use same MA values (check debug output)        â•‘
â•‘  âœ… Test closeâ†’reverse scenario (exit SELL, enter BUY same bar)      â•‘
â•‘  âœ… Verify MA lines draw correctly on chart                          â•‘
â•‘  âœ… Run 3+ month backtest, compare to v5.7 results                   â•‘
â•‘  âœ… Set InpEnableDebug = false for production                        â•‘
â•‘                                                                      â•‘
â•‘  EXPECTED BEHAVIOR:                                                  â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â•‘
â•‘  ğŸ”„ UpdateMABuffers() called FIRST each new bar                      â•‘
â•‘  ğŸŸ¢ Fast>Slow â†’ BUY signal (if conditions met)                       â•‘
â•‘  ğŸ”´ Fast<Slow â†’ SELL signal (if conditions met)                      â•‘
â•‘  ğŸšª Exit signal â†’ Close same-direction positions                     â•‘
â•‘  âœ… Reverse entry can happen same bar (now using synchronized data)  â•‘
â•‘  ğŸ“Š MA lines visible on chart matching indicator calculations        â•‘
â•‘                                                                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
*/

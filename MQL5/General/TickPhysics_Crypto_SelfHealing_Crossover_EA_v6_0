//+------------------------------------------------------------------+
//|      TickPhysics_Crypto_SelfHealing_Crossover_EA_v6_0            |
//|    MA Crossover BASELINE - Simple, Deterministic, Binary         |
//|    Version 6.0 - UNIFIED MA PARAMETERS (Entry = Exit)            |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, QuanAlpha"
#property version   "6.0"
#property strict

#include <Trade\Trade.mqh>

//============================= VERSION TRACKING =========================//
string EA_VERSION = "6.0_UnifiedMA_Binary";
string EA_NAME = "TickPhysics_Crossover_Baseline";

//============================= v6.0 CHANGELOG ===========================//
// MAJOR SIMPLIFICATION FOR BINARY WIN/LOSS TRACKING:
// 1. [OK] UNIFIED MA PARAMETERS: Entry and Exit now use SAME MA pair
//    - InpMAFast (10) and InpMASlow (30) used for BOTH entry AND exit
//    - Eliminates parameter drift between entry/exit logic
//    - Every crossover is BOTH an entry signal AND an exit signal
// 2. [OK] DETERMINISTIC SIGNALS: Guaranteed close->reverse behavior
//    - Fast crosses above Slow = Close SELL + Open BUY
//    - Fast crosses below Slow = Close BUY + Open SELL
//    - No more missed reverse entries!
// 3. [OK] BINARY WIN/LOSS: Perfect for CSV/Python/Self-Learning
//    - Every trade has a clear entry and exit
//    - Repeatable, testable, provable results
//    - Clean data for machine learning optimization
// 4. [OK] MAINTAINED FROM v5.8: Global buffer synchronization
//    - UpdateMABuffers() called once per bar
//    - All functions use synchronized global MA data
//========================================================================//

//============================= CSV LOGGING ==============================//
input group "=== CSV LOGGING (Self-Healing) ==="
input bool InpEnableSignalLog = true;
input bool InpEnableTradeLog = true;
input string InpSignalLogFile = "TP_Crypto_Signals_Cross_v5_9.csv";
input string InpTradeLogFile = "TP_Crypto_Trades_Cross_v5_9.csv";

//============================= SELF-LEARNING ============================//
input group "=== Self-Learning System (v5.8) ==="
input bool InpEnableLearning = true;
input string InpLearningFile = "TP_Learning_Cross_v5_9.json";

//============================= INDICATOR SETTINGS =======================//
input group "=== TickPhysics Indicator ==="
input string InpIndicatorName = "TickPhysics_Crypto_Indicator_v2_1";

//============================= MA CROSSOVER BASELINE ====================//
input group "=== MA Crossover Baseline (Deterministic Entry/Exit) ==="
input bool InpUseMAEntry = true;              // Use MA crossover for entry
input bool InpUseMAExit = true;               // Use MA crossover for exit (same MA as entry)
input int InpMAFast = 10;                     // Fast MA (entry AND exit)
input int InpMASlow = 30;                     // Slow MA (entry AND exit)
input ENUM_MA_METHOD InpMAMethod = MODE_EMA;  // MA calculation method
input ENUM_APPLIED_PRICE InpMAPrice = PRICE_CLOSE; // MA applied price
input int InpCrossoverConfirmBars = 1;        // Crossover confirmation bars (1=immediate, 2=1-bar delay)

//============================= RISK MANAGEMENT ==========================//
input group "=== Risk Management (v5.0 SAFE DEFAULTS) ==="
input double InpRiskPerTradePercent = 2.0;    // Risk per trade (% of equity)
input double InpStopLossPercent = 3.0;        // Stop Loss (% of PRICE)
input double InpTakeProfitPercent = 2.0;      // Take Profit (% of PRICE)
input double InpMoveToBEAtPercent = 1.0;      // Move to BE at (% profit)
input int InpMaxPositions = 1;
input int InpMaxConsecutiveLosses = 3;

//============================= ENTRY FILTERS ============================//
input group "=== Entry Filters (Self-Optimizing) ==="
input double InpMinTrendQuality = 70.0;
input double InpMinConfluence = 60.0;
input double InpMinMomentum = 50.0;
input bool InpRequireGreenZone = false;
input bool InpTradeOnlyNormalRegime = false;
input int InpDisallowAfterDivergence = 5;
input double InpMaxSpread = 500.0;            // Max spread

//============================= ENTROPY FILTER ===========================//
input group "=== Entropy Filter (Chaos Detection) ==="
input bool InpUseEntropyFilter = false;       // Enable chaos detection
input double InpMaxEntropy = 2.5;             // Max allowed entropy

//============================= ADAPTIVE SL/TP ===========================//
input group "=== Adaptive SL/TP (ATR-based) ==="
input bool InpUseAdaptiveSLTP = false;        // ATR-based adjustment
input double InpATRMultiplierSL = 2.0;        // ATR multiplier for SL
input double InpATRMultiplierTP = 4.0;        // ATR multiplier for TP

//============================= DAILY GOVERNANCE =========================//
input group "=== Daily Governance ==="
input double InpDailyProfitTarget = 10.0;
input double InpDailyDrawdownLimit = 10.0;
input bool InpPauseOnLimits = false;

//============================= SESSION TIMES ============================//
input group "=== Trading Hours ==="
input bool InpUseSessionFilter = false;
input string InpSessionStart = "00:00";
input string InpSessionEnd = "23:59";

//============================= PHYSICS & SELF-HEALING ===================//
input group "=== Physics & Self-Healing (Toggle for Controlled QA) ==="
input bool InpUsePhysics = false;             // Enable physics filters
input bool InpUseSelfHealing = false;         // Enable self-healing optimization
input bool InpUseTickPhysicsIndicator = false; // Use TickPhysics indicator signals

//============================= CHART DISPLAY ============================//
input group "=== Chart Display ==="
input bool InpShowMALines = true;             // Show MA lines on chart
input color InpColorFastEntry = clrBlue;      // Fast Entry MA color
input color InpColorSlowEntry = clrYellow;    // Slow Entry MA color
input color InpColorExit = clrWhite;          // Exit MA color
input int InpMALineWidth = 2;                 // MA line width

//============================= DEBUG MODE (v5.8) ========================//
input group "=== Debug Mode (v5.8 - Buffer Synchronization) ==="
input bool InpEnableDebug = true;             // Enable debug logging

//============================= GLOBAL VARIABLES =========================//
CTrade trade;
int indicatorHandle = INVALID_HANDLE;
datetime lastBarTime = 0;
datetime lastSignalLogTime = 0;

// MA handles for baseline crossover
int maFastEntry_Handle = INVALID_HANDLE;
int maSlowEntry_Handle = INVALID_HANDLE;
int maFastExit_Handle = INVALID_HANDLE;
int maSlowExit_Handle = INVALID_HANDLE;

// ✅ v5.8: GLOBAL MA BUFFERS (synchronized across all functions)
double g_maFastEntry[];   // Global buffer for Fast Entry MA
double g_maSlowEntry[];   // Global buffer for Slow Entry MA
double g_maFastExit[];    // Global buffer for Fast Exit MA
double g_maSlowExit[];    // Global buffer for Slow Exit MA

// Chart window for MA display
int chartWindow = 0;

// Daily tracking
double dailyStartBalance = 0;
int dailyTradeCount = 0;
int consecutiveLosses = 0;
bool dailyPaused = false;
datetime lastDayCheck = 0;

// CSV handles
int signalLogHandle = INVALID_HANDLE;
int tradeLogHandle = INVALID_HANDLE;

// Watchdog
datetime lastTickTime = 0;

// Track last signal to prevent duplicate entries
static int lastSignalProcessed = 0;
static datetime lastSignalTime = 0;

// ✅ v6.0: Track if we closed a position this bar (for accurate position counting)
static bool positionClosedThisBar = false;

//============================= v5.0: TRADE TRACKER =======================//
struct TradeTracker
{
   ulong ticket;
   datetime openTime;
   double openPrice;
   double sl;
   double tp;
   double lots;
   ENUM_ORDER_TYPE type;
   // Entry conditions
   double entryQuality;
   double entryConfluence;
   double entryZone;
   double entryRegime;
   double entryEntropy;
   double entryMAFast;
   double entryMASlow;
   double entrySpread;
   // MFE/MAE tracking
   double mfe;
   double mae;
};

TradeTracker currentTrades[];

//============================= v5.0: LEARNING STRUCTURE =================//
struct LearningParameters
{
   double MinTrendQuality;
   double MinConfluence;
   double MinMomentum;
   double StopLossPercent;
   double TakeProfitPercent;
   double RiskPerTradePercent;
   
   int totalTrades;
   double winRate;
   double profitFactor;
   double sharpeRatio;
   double maxDrawdown;
   double avgWin;
   double avgLoss;
   double avgRRatio;
   
   string adjustQuality;
   string adjustConfluence;
   string adjustSL;
   string adjustTP;
   string adjustRisk;
   string reason;
   
   datetime lastUpdate;
   string version;
   int learningCycle;
};

LearningParameters learningData;

// Indicator buffer indices
#define BUFFER_SPEED 0
#define BUFFER_ACCEL 1
#define BUFFER_ACCEL_COLOR 2
#define BUFFER_MOMENTUM 3
#define BUFFER_QUALITY 4
#define BUFFER_QUALITY_COLOR 5
#define BUFFER_DISTANCE_ROC 6
#define BUFFER_JERK 7
#define BUFFER_HIGH_THRESHOLD 8
#define BUFFER_LOW_THRESHOLD 9
#define BUFFER_ZERO_LINE 10
#define BUFFER_QUALITY_GLOW 11
#define BUFFER_MOM_SPIKE 12
#define BUFFER_MOM_SPIKE_COLOR 13
#define BUFFER_CONFLUENCE 14
#define BUFFER_CONFLUENCE_COLOR 15
#define BUFFER_VOL_REGIME 16
#define BUFFER_VOL_REGIME_COLOR 17
#define BUFFER_DIVERGENCE 18
#define BUFFER_DIVERGENCE_COLOR 19
#define BUFFER_TRADING_ZONE 20
#define BUFFER_ZONE_COLOR 21
#define BUFFER_ENTROPY 22

//============================= CHUNK 2: HELPER FUNCTIONS ================//

//========================================================================//
//===================== v5.7: HELPER FUNCTIONS ===========================//
//========================================================================//

// Returns the OPPOSITE order type
ENUM_ORDER_TYPE GetOppositeOrderType(ENUM_ORDER_TYPE orderType)
{
   return (orderType == ORDER_TYPE_BUY) ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
}

// Checks if there's an open position in the specified direction
bool HasOpenPositionInDirection(ENUM_ORDER_TYPE orderType)
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      // Robust: select the position context by ticket before accessing its properties
      if(!PositionSelectByTicket(ticket))
         continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;

      ENUM_ORDER_TYPE posType = (ENUM_ORDER_TYPE)PositionGetInteger(POSITION_TYPE);
      if(posType == orderType)
         return true;
   }
   return false;
}

//========================================================================//
//=================== v5.8: UPDATE MA BUFFERS (NEW) ======================//
//========================================================================//
// ✅ v5.8: CRITICAL NEW FUNCTION
// Updates all global MA buffers once per bar
// This ensures ALL functions use synchronized MA data
//========================================================================//

bool UpdateMABuffers()
{
   if(InpEnableDebug)
      Print("DEBUG: UpdateMABuffers() called - Syncing global buffers");
   
   // Set arrays as time series (index 0 = most recent)
   ArraySetAsSeries(g_maFastEntry, true);
   ArraySetAsSeries(g_maSlowEntry, true);
   ArraySetAsSeries(g_maFastExit, true);
   ArraySetAsSeries(g_maSlowExit, true);
   
   // Copy Entry MA buffers (need 3 bars for crossover detection)
   if(CopyBuffer(maFastEntry_Handle, 0, 0, 3, g_maFastEntry) < 3)
   {
      if(InpEnableDebug)
         Print("DEBUG: Failed to copy Fast Entry MA buffer");
      return false;
   }
   
   if(CopyBuffer(maSlowEntry_Handle, 0, 0, 3, g_maSlowEntry) < 3)
   {
      if(InpEnableDebug)
         Print("DEBUG: Failed to copy Slow Entry MA buffer");
      return false;
   }
   
   // Copy Exit MA buffers (if enabled)
   if(InpUseMAExit)
   {
      if(CopyBuffer(maFastExit_Handle, 0, 0, 3, g_maFastExit) < 3)
      {
         if(InpEnableDebug)
            Print("DEBUG: Failed to copy Fast Exit MA buffer");
         return false;
      }
      
      if(CopyBuffer(maSlowExit_Handle, 0, 0, 3, g_maSlowExit) < 3)
      {
         if(InpEnableDebug)
            Print("DEBUG: Failed to copy Slow Exit MA buffer");
         return false;
      }
   }
   
   if(InpEnableDebug)
   {
      Print("DEBUG: MA Buffers updated successfully:");
      Print("   Entry Fast[0]=", g_maFastEntry[0], " | Slow[0]=", g_maSlowEntry[0]);
      if(InpUseMAExit)
         Print("   Exit Fast[0]=", g_maFastExit[0], " | Slow[0]=", g_maSlowExit[0]);
   }
   
   return true;
}

//========================================================================//
//=================== v6.0.3: ENTRY SIGNAL - CONFIGURABLE CROSSOVER =====//
//========================================================================//
// ✅ v6.0.3 FIX: CONFIGURABLE crossover detection
// InpCrossoverConfirmBars = 1: Fast[0] vs Fast[1] (immediate, standard)
// InpCrossoverConfirmBars = 2: Fast[0] vs Fast[2] (1-bar confirmation delay)
// 
// BULLISH: Fast[0] > Slow[0] AND Fast[N] <= Slow[N]
// BEARISH: Fast[0] < Slow[0] AND Fast[N] >= Slow[N]
// where N = InpCrossoverConfirmBars
//
// This allows you to backtest:
// - Immediate entry (N=1): Maximum responsiveness, may have more whipsaws
// - Confirmed entry (N=2): 1-bar delay, filters false signals, higher win rate
//
// Returns (1=BUY crossover, -1=SELL crossover, 0=NO_CROSSOVER)
//========================================================================//

int GetMACrossoverSignal()
{
   if(!InpUseMAEntry)
      return 0;
   
   if(InpEnableDebug)
      Print("DEBUG: GetMACrossoverSignal() - CONFIGURABLE crossover (confirm bars=", InpCrossoverConfirmBars, ")");
   
   // ✅ v6.0.3: Use global buffers (already updated in OnTick)
   if(InpEnableDebug)
   {
      Print("DEBUG: MA VALUES:");
      Print("   Fast[0]=", g_maFastEntry[0], " | Slow[0]=", g_maSlowEntry[0]);
      Print("   Fast[", InpCrossoverConfirmBars, "]=", g_maFastEntry[InpCrossoverConfirmBars], 
            " | Slow[", InpCrossoverConfirmBars, "]=", g_maSlowEntry[InpCrossoverConfirmBars]);
   }
   
   // ✅ BULLISH CROSSOVER: Fast crosses ABOVE Slow
   // Current bar: Fast > Slow
   // Previous bar (or N bars ago): Fast <= Slow
   bool bullishCross = (g_maFastEntry[0] > g_maSlowEntry[0]) && 
                       (g_maFastEntry[InpCrossoverConfirmBars] <= g_maSlowEntry[InpCrossoverConfirmBars]);
   
   // ✅ BEARISH CROSSOVER: Fast crosses BELOW Slow
   // Current bar: Fast < Slow
   // Previous bar (or N bars ago): Fast >= Slow
   bool bearishCross = (g_maFastEntry[0] < g_maSlowEntry[0]) && 
                       (g_maFastEntry[InpCrossoverConfirmBars] >= g_maSlowEntry[InpCrossoverConfirmBars]);
   
   if(bullishCross)
   {
      Print("BULLISH CROSSOVER DETECTED!");
      Print("   Fast[0]=", g_maFastEntry[0], " > Slow[0]=", g_maSlowEntry[0]);
      Print("   Fast[", InpCrossoverConfirmBars, "]=", g_maFastEntry[InpCrossoverConfirmBars], 
            " <= Slow[", InpCrossoverConfirmBars, "]=", g_maSlowEntry[InpCrossoverConfirmBars]);
      return 1;  // BUY signal
   }
   
   if(bearishCross)
   {
      Print("BEARISH CROSSOVER DETECTED!");
      Print("   Fast[0]=", g_maFastEntry[0], " < Slow[0]=", g_maSlowEntry[0]);
      Print("   Fast[", InpCrossoverConfirmBars, "]=", g_maFastEntry[InpCrossoverConfirmBars], 
            " >= Slow[", InpCrossoverConfirmBars, "]=", g_maSlowEntry[InpCrossoverConfirmBars]);
      return -1;  // SELL signal
   }
   
   if(InpEnableDebug)
      Print("DEBUG: No crossover detected this bar");
   
   return 0;
}

//========================================================================//
//=================== v6.0: EXIT SIGNAL - RELATIONSHIP BASED ============//
//========================================================================//
// ✅ v6.0.1 FIX: Exit based on MA RELATIONSHIP, not strict crossover
// This catches intrabar crossovers that we might miss with bar-close logic
// If you're in a BUY and Fast is now below Slow = CLOSE
// If you're in a SELL and Fast is now above Slow = CLOSE
// Returns: ORDER_TYPE_BUY to close BUY positions, ORDER_TYPE_SELL to close SELL
// Returns: -1 if no exit signal
//========================================================================//

int GetPositionTypeToClose()
{
   if(!InpUseMAExit)
      return -1;  // No exit signal
   
   // Check what positions we currently have
   bool hasBuyPosition = HasOpenPositionInDirection(ORDER_TYPE_BUY);
   bool hasSellPosition = HasOpenPositionInDirection(ORDER_TYPE_SELL);
   
   // Current MA relationship
   bool fastAboveSlow = (g_maFastExit[0] > g_maSlowExit[0]);
   bool fastBelowSlow = (g_maFastExit[0] < g_maSlowExit[0]);
   
   // If we have a BUY but Fast is now BELOW Slow = wrong side, close it
   if(hasBuyPosition && fastBelowSlow)
   {
      Print("EXIT SIGNAL: Fast below Slow - Close BUY positions");
      Print("   Fast[0]=", g_maFastExit[0], " | Slow[0]=", g_maSlowExit[0]);
      return ORDER_TYPE_BUY;
   }
   
   // If we have a SELL but Fast is now ABOVE Slow = wrong side, close it
   if(hasSellPosition && fastAboveSlow)
   {
      Print("EXIT SIGNAL: Fast above Slow - Close SELL positions");
      Print("   Fast[0]=", g_maFastExit[0], " | Slow[0]=", g_maSlowExit[0]);
      return ORDER_TYPE_SELL;
   }
   
   return -1;  // No exit signal
}

//========================================================================//
//=================== v5.7: MANAGE POSITIONS (FIXED) ====================//
//========================================================================//
// ✅ v5.7: Exit logic correctly closes SAME type positions
// ✅ v5.8: Now uses global buffers for consistency
//========================================================================//

void ManagePositions()
{
   if(InpEnableDebug)
      Print("DEBUG: ManagePositions() START");

   // ✅ v6.0: Reset the flag at the start of position management
   positionClosedThisBar = false;

   int exitSignal = GetPositionTypeToClose();

   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      // Select position by ticket to ensure PositionGet* calls refer to this position
      if(!PositionSelectByTicket(ticket))
         continue;

      if(PositionGetString(POSITION_SYMBOL) != _Symbol)
         continue;

      ENUM_ORDER_TYPE orderType = (ENUM_ORDER_TYPE)PositionGetInteger(POSITION_TYPE);

      // Close position if exit signal matches this position type
      if(exitSignal == (int)orderType)
      {
         if(trade.PositionClose(ticket))
         {
            Print("Position closed on MA exit signal: #", ticket);
            LogTradeClose(ticket, "MA_Exit_Signal");
            positionClosedThisBar = true;  // ✅ v6.0: Mark that we closed a position
            if(InpEnableDebug)
               Print("   Position #", ticket, " closed successfully");
         }
         continue;
      }

      // Move to breakeven logic
      double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentPrice = (orderType == ORDER_TYPE_BUY) ? 
         SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      double profitPercent = 0;
      if(orderType == ORDER_TYPE_BUY)
         profitPercent = ((currentPrice - openPrice) / openPrice) * 100.0;
      else
         profitPercent = ((openPrice - currentPrice) / openPrice) * 100.0;

      if(profitPercent >= InpMoveToBEAtPercent)
      {
         bool needUpdate = false;

         if(orderType == ORDER_TYPE_BUY && currentSL < openPrice)
            needUpdate = true;
         else if(orderType == ORDER_TYPE_SELL && currentSL > openPrice)
            needUpdate = true;

         if(needUpdate)
         {
            if(trade.PositionModify(ticket, openPrice, PositionGetDouble(POSITION_TP)))
            {
               Print("Moved to breakeven: #", ticket);
            }
         }
      }

      UpdateMFEMAE();
   }

   if(InpEnableDebug)
      Print("DEBUG: ManagePositions() END");
}

//========================================================================//
//=================== COUNT POSITIONS ====================================//
//========================================================================//

int CountPositions()
{
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket))
         continue;
      if(PositionGetString(POSITION_SYMBOL) == _Symbol)
         count++;
   }
   return count;
}

// -----------------------------------------------------------------------
// Get daily P/L (percentage) - added to resolve undeclared identifier errors
// -----------------------------------------------------------------------

double GetDailyPnL()
{
   double currentEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   if(dailyStartBalance <= 0.0) return 0.0;
   return ((currentEquity - dailyStartBalance) / dailyStartBalance) * 100.0;
}

//========================================================================

//========================================================================//
//=================== CHECK DAILY RESET ==================================//
//========================================================================//

void CheckDailyReset()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   if(timeStruct.day != lastDayCheck)
   {
      lastDayCheck = timeStruct.day;
      dailyStartBalance = AccountInfoDouble(ACCOUNT_EQUITY);
      dailyTradeCount = 0;
      dailyPaused = false;
      
      Print("-----------------------------");
      Print("NEW TRADING DAY - Daily stats reset");
      Print("   Starting balance: ", dailyStartBalance);
      Print("-----------------------------");
   }
   
   if(InpPauseOnLimits && !dailyPaused)
   {
      double pnl = GetDailyPnL();
      
      if(pnl >= InpDailyProfitTarget)
      {
         Print("Daily profit target reached: ", pnl, "%");
         dailyPaused = true;
      }
      
      if(pnl <= -InpDailyDrawdownLimit)
      {
         Print("Daily drawdown limit reached: ", pnl, "%");
         dailyPaused = true;
      }
   }
}

//========================================================================//
//=================== CHECK SESSION ======================================//
//========================================================================//

bool IsWithinSession()
{
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
   
   string startParts[];
   string endParts[];
   StringSplit(InpSessionStart, ':', startParts);
   StringSplit(InpSessionEnd, ':', endParts);
   
   int startMinutes = (int)StringToInteger(startParts[0]) * 60 + (int)StringToInteger(startParts[1]);
   int endMinutes = (int)StringToInteger(endParts[0]) * 60 + (int)StringToInteger(endParts[1]);
   
   if(startMinutes <= endMinutes)
      return (currentMinutes >= startMinutes && currentMinutes <= endMinutes);
   else
      return (currentMinutes >= startMinutes || currentMinutes <= endMinutes);
}

//============================= CHUNK 5: LOGGING FUNCTIONS ===============//

//========================================================================//
//=================== v5.0: LOG TRADE CLOSE ==============================//
//========================================================================//

void LogTradeClose(ulong ticket, string exitReason)
{
   int trackerIndex = -1;
   for(int i = 0; i < ArraySize(currentTrades); i++)
   {
      if(currentTrades[i].ticket == ticket)
      {
         trackerIndex = i;
         break;
      }
   }
   
   if(trackerIndex < 0)
   {
      Print("WARNING: No tracker found for closed trade: ", ticket);
      return;
   }
   
   if(!HistorySelectByPosition(ticket))
   {
      Print("ERROR: Cannot find trade in history: ", ticket);
      return;
   }
   
   int totalDeals = HistoryDealsTotal();
   ulong closeDeal = 0;
   double profit = 0;
   double exitPrice = 0;
   datetime exitTime = 0;
   
   for(int i = totalDeals - 1; i >= 0; i--)
   {
      closeDeal = HistoryDealGetTicket(i);
      if(HistoryDealGetInteger(closeDeal, DEAL_POSITION_ID) == ticket &&
         HistoryDealGetInteger(closeDeal, DEAL_ENTRY) == DEAL_ENTRY_OUT)
      {
         profit = HistoryDealGetDouble(closeDeal, DEAL_PROFIT);
         exitPrice = HistoryDealGetDouble(closeDeal, DEAL_PRICE);
         exitTime = (datetime)HistoryDealGetInteger(closeDeal, DEAL_TIME);
         break;
      }
   }
   
   double exitQuality = 0, exitConfluence = 0;
   if(InpUsePhysics && InpUseTickPhysicsIndicator)
   {
      double qBuf[1], cBuf[1];
      if(CopyBuffer(indicatorHandle, BUFFER_QUALITY, 0, 1, qBuf) > 0) exitQuality = qBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_CONFLUENCE, 0, 1, cBuf) > 0) exitConfluence = cBuf[0];
   }
   
   double profitPercent = (profit / AccountInfoDouble(ACCOUNT_EQUITY)) * 100.0;
   
   double pips = 0;
   if(currentTrades[trackerIndex].type == ORDER_TYPE_BUY)
      pips = (exitPrice - currentTrades[trackerIndex].openPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   else
      pips = (currentTrades[trackerIndex].openPrice - exitPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   
   int holdTimeBars = (int)((exitTime - currentTrades[trackerIndex].openTime) / PeriodSeconds(_Period));
   
   double mfePercent = 0, maePercent = 0, mfePips = 0, maePips = 0;
   if(currentTrades[trackerIndex].type == ORDER_TYPE_BUY)
   {
      mfePercent = ((currentTrades[trackerIndex].mfe - currentTrades[trackerIndex].openPrice) / currentTrades[trackerIndex].openPrice) * 100.0;
      maePercent = ((currentTrades[trackerIndex].mae - currentTrades[trackerIndex].openPrice) / currentTrades[trackerIndex].openPrice) * 100.0;
      mfePips = (currentTrades[trackerIndex].mfe - currentTrades[trackerIndex].openPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
      maePips = (currentTrades[trackerIndex].mae - currentTrades[trackerIndex].openPrice) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   }
   else
   {
      mfePercent = ((currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mfe) / currentTrades[trackerIndex].openPrice) * 100.0;
      maePercent = ((currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mae) / currentTrades[trackerIndex].openPrice) * 100.0;
      mfePips = (currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mfe) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
      maePips = (currentTrades[trackerIndex].openPrice - currentTrades[trackerIndex].mae) / SymbolInfoDouble(_Symbol, SYMBOL_POINT) / 10;
   }
   
   double riskPercent = InpRiskPerTradePercent;
   double rRatio = (riskPercent != 0) ? (profitPercent / riskPercent) : 0;
   
   MqlDateTime entryTime, closeTime;
   TimeToStruct(currentTrades[trackerIndex].openTime, entryTime);
   TimeToStruct(exitTime, closeTime);
   
   int handle = FileOpen(InpTradeLogFile, FILE_READ|FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(handle == INVALID_HANDLE)
   {
      Print("ERROR: Could not open trade log file");
      return;
   }
   
   FileSeek(handle, 0, SEEK_END);
   
   FileWrite(handle,
      TimeToString(currentTrades[trackerIndex].openTime), ticket, _Symbol, "CLOSE", 
      (currentTrades[trackerIndex].type == ORDER_TYPE_BUY) ? "BUY" : "SELL",
      currentTrades[trackerIndex].lots, currentTrades[trackerIndex].openPrice, currentTrades[trackerIndex].sl, currentTrades[trackerIndex].tp,
      currentTrades[trackerIndex].entryQuality, currentTrades[trackerIndex].entryConfluence, currentTrades[trackerIndex].entryZone, currentTrades[trackerIndex].entryRegime, currentTrades[trackerIndex].entryEntropy,
      currentTrades[trackerIndex].entryMAFast, currentTrades[trackerIndex].entryMASlow, currentTrades[trackerIndex].entrySpread,
      exitPrice, exitReason, profit, profitPercent, pips,
      exitQuality, exitConfluence, holdTimeBars,
      currentTrades[trackerIndex].mfe, currentTrades[trackerIndex].mae, mfePercent, maePercent, mfePips, maePips,
      riskPercent, rRatio,
      entryTime.hour, entryTime.day_of_week, closeTime.hour
   );
   
   FileClose(handle);
   
   // Update consecutive losses counter
   if(profit < 0)
      consecutiveLosses++;
   else
      consecutiveLosses = 0;
   
   // Remove from tracker
   int size = ArraySize(currentTrades);
   for(int i = trackerIndex; i < size - 1; i++)
   {
      currentTrades[i] = currentTrades[i + 1];
   }
   ArrayResize(currentTrades, size - 1);
}

//========================================================================//
//=================== LOG SIGNAL =========================================//
//========================================================================//

void LogSignal(int signal, double quality, double confluence, double momentum, 
               double tradingZone, double volRegime, double entropy,
               bool physicsPass, string rejectReason)
{
   // ✅ v5.8: Use global MA buffers
   double maFastEntry = g_maFastEntry[0];
   double maSlowEntry = g_maSlowEntry[0];
   double maFastExit = InpUseMAExit ? g_maFastExit[0] : 0;
   double maSlowExit = InpUseMAExit ? g_maSlowExit[0] : 0;
   
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double spread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   MqlDateTime timeStruct;
   TimeToStruct(TimeCurrent(), timeStruct);
   
   int handle = FileOpen(InpSignalLogFile, FILE_READ|FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(handle == INVALID_HANDLE)
   {
      Print("ERROR: Could not open signal log file");
      return;
   }
   
   FileSeek(handle, 0, SEEK_END);
   
   string signalType = (signal == 1) ? "BULLISH_CROSS" : (signal == -1) ? "BEARISH_CROSS" : "NO_SIGNAL";
   
   FileWrite(handle,
      TimeToString(TimeCurrent()), signal, signalType,
      maFastEntry, maSlowEntry, maFastExit, maSlowExit,
      quality, confluence, momentum, tradingZone, volRegime, entropy,
      currentPrice, spread, timeStruct.hour, timeStruct.day_of_week,
      (InpUsePhysics ? "YES" : "NO"), (physicsPass ? "PASS" : "REJECT"), rejectReason
   );
   
   FileClose(handle);
}

//============================= CHUNK 3: PHYSICS & TRADING ===============//

//========================================================================//
//=================== CHECK PHYSICS FILTERS ==============================//
//========================================================================//

bool CheckPhysicsFilters(int signal, double quality, double confluence, 
                         double tradingZone, double volRegime, double entropy,
                         string &rejectReason)
{
   if(!InpUsePhysics || !InpUseTickPhysicsIndicator)
   {
      rejectReason = "N/A_Physics_Disabled";
      return true;
   }
   
   if(quality < InpMinTrendQuality)
   {
      rejectReason = StringFormat("Quality_Too_Low_%.1f<%.1f", quality, InpMinTrendQuality);
      return false;
   }
   
   if(confluence < InpMinConfluence)
   {
      rejectReason = StringFormat("Confluence_Too_Low_%.1f<%.1f", confluence, InpMinConfluence);
      return false;
   }
   
   if(InpRequireGreenZone)
   {
      bool isGreenZone = (signal == 1 && tradingZone == 0) || (signal == -1 && tradingZone == 1);
      if(!isGreenZone)
      {
         rejectReason = "Not_In_Green_Zone";
         return false;
      }
   }
   
   if(InpTradeOnlyNormalRegime && volRegime != 0)
   {
      rejectReason = StringFormat("Regime_Not_Normal_%.0f", volRegime);
      return false;
   }
   
   if(InpUseEntropyFilter && entropy > InpMaxEntropy)
   {
      rejectReason = StringFormat("Entropy_Too_High_%.2f>%.2f", entropy, InpMaxEntropy);
      return false;
   }
   
   double spread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   if(spread > InpMaxSpread)
   {
      rejectReason = StringFormat("Spread_Too_Wide_%.1f>%.1f", spread, InpMaxSpread);
      return false;
   }
   
   rejectReason = "All_Filters_Pass";
   return true;
}

//========================================================================//
//=================== OPEN POSITION ======================================//
//========================================================================//

bool OpenPosition(ENUM_ORDER_TYPE orderType)
{
   double currentPrice = (orderType == ORDER_TYPE_BUY) ? 
      SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   
   double slDistance = currentPrice * (InpStopLossPercent / 100.0);
   double tpDistance = currentPrice * (InpTakeProfitPercent / 100.0);
   
   double sl = 0, tp = 0;
   if(orderType == ORDER_TYPE_BUY)
   {
      sl = currentPrice - slDistance;
      tp = currentPrice + tpDistance;
   }
   else
   {
      sl = currentPrice + slDistance;
      tp = currentPrice - tpDistance;
   }
   
   double riskAmount = AccountInfoDouble(ACCOUNT_EQUITY) * (InpRiskPerTradePercent / 100.0);
   double lots = riskAmount / (slDistance / SymbolInfoDouble(_Symbol, SYMBOL_POINT) * SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE));
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   
   lots = MathMax(minLot, MathMin(maxLot, MathRound(lots / lotStep) * lotStep));
   
   if(InpEnableDebug)
   {
      Print("DEBUG: Opening position:");
      Print("   Type: ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"));
      Print("   Price: ", currentPrice);
      Print("   SL: ", sl, " (", slDistance, " distance)");
      Print("   TP: ", tp, " (", tpDistance, " distance)");
      Print("   Lots: ", lots);
   }
   
   trade.SetExpertMagicNumber(123456);
   trade.SetDeviationInPoints(50);
   
   bool result = false;
   if(orderType == ORDER_TYPE_BUY)
      result = trade.Buy(lots, _Symbol, currentPrice, sl, tp, "TickPhysics_v5.8");
   else
      result = trade.Sell(lots, _Symbol, currentPrice, sl, tp, "TickPhysics_v5.8");
   
   if(!result)
   {
      Print("Trade failed: ", trade.ResultRetcode(), " - ", trade.ResultRetcodeDescription());
      return false;
   }
   
   ulong ticket = trade.ResultOrder();
   Print("Position opened: #", ticket, " | ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"), 
         " | Lots: ", lots, " | Entry: ", currentPrice);
   
   // Track the trade
   int size = ArraySize(currentTrades);
   ArrayResize(currentTrades, size + 1);
   
   currentTrades[size].ticket = ticket;
   currentTrades[size].openTime = TimeCurrent();
   currentTrades[size].openPrice = currentPrice;
   currentTrades[size].sl = sl;
   currentTrades[size].tp = tp;
   currentTrades[size].lots = lots;
   currentTrades[size].type = orderType;
   
   // Store entry conditions using global buffers
   currentTrades[size].entryMAFast = g_maFastEntry[0];
   currentTrades[size].entryMASlow = g_maSlowEntry[0];
   currentTrades[size].entrySpread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   if(InpUsePhysics && InpUseTickPhysicsIndicator)
   {
      double qBuf[1], cBuf[1], zBuf[1], rBuf[1], eBuf[1];
      if(CopyBuffer(indicatorHandle, BUFFER_QUALITY, 0, 1, qBuf) > 0) currentTrades[size].entryQuality = qBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_CONFLUENCE, 0, 1, cBuf) > 0) currentTrades[size].entryConfluence = cBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_TRADING_ZONE, 0, 1, zBuf) > 0) currentTrades[size].entryZone = zBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_VOL_REGIME, 0, 1, rBuf) > 0) currentTrades[size].entryRegime = rBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_ENTROPY, 0, 1, eBuf) > 0) currentTrades[size].entryEntropy = eBuf[0];
   }
   
   currentTrades[size].mfe = currentPrice;
   currentTrades[size].mae = currentPrice;
   
   // Log to file
   if(InpEnableTradeLog)
   {
      int handle = FileOpen(InpTradeLogFile, FILE_READ|FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
      if(handle != INVALID_HANDLE)
      {
         FileSeek(handle, 0, SEEK_END);
         FileWrite(handle,
            TimeToString(TimeCurrent()), ticket, _Symbol, "OPEN",
            (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"),
            lots, currentPrice, sl, tp,
            currentTrades[size].entryQuality, currentTrades[size].entryConfluence,
            currentTrades[size].entryZone, currentTrades[size].entryRegime,
            currentTrades[size].entryEntropy, currentTrades[size].entryMAFast,
            currentTrades[size].entryMASlow, currentTrades[size].entrySpread
         );
         FileClose(handle);
      }
   }
   
   return true;
}

//========================================================================//
//=================== UPDATE MFE/MAE =====================================//
//========================================================================//

void UpdateMFEMAE()
{
   for(int i = 0; i < ArraySize(currentTrades); i++)
   {
      double currentPrice = 0;

      for(int p = 0; p < PositionsTotal(); p++)
      {
         ulong pTicket = PositionGetTicket(p);
         if(pTicket == 0) continue;
         if(pTicket != currentTrades[i].ticket) continue;
         if(!PositionSelectByTicket(pTicket))
            continue;
         currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
         break;
      }

      if(currentPrice == 0) continue;

      if(currentTrades[i].type == ORDER_TYPE_BUY)
      {
         if(currentPrice > currentTrades[i].mfe)
            currentTrades[i].mfe = currentPrice;
         if(currentPrice < currentTrades[i].mae)
            currentTrades[i].mae = currentPrice;
      }
      else
      {
         if(currentPrice < currentTrades[i].mfe)
            currentTrades[i].mfe = currentPrice;
         if(currentPrice > currentTrades[i].mae)
            currentTrades[i].mae = currentPrice;
      }
   }
}

//============================= CHUNK 7: CSV INIT & DISPLAY ==============//

//========================================================================//
//=================== INITIALIZE SIGNAL LOG ==============================//
//========================================================================//

bool InitSignalLog()
{
   signalLogHandle = FileOpen(InpSignalLogFile, FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(signalLogHandle == INVALID_HANDLE)
   {
      Print("Failed to create signal log: ", InpSignalLogFile);
      return false;
   }
   
   FileWrite(signalLogHandle, 
      "Timestamp", "Signal", "SignalType",
      "MA_Fast_Entry", "MA_Slow_Entry", "MA_Fast_Exit", "MA_Slow_Exit",
      "Quality", "Confluence", "Momentum", "TradingZone", "VolRegime", "Entropy",
      "Price", "Spread", "Hour", "DayOfWeek",
      "PhysicsEnabled", "PhysicsPass", "RejectReason"
   );
   
   FileClose(signalLogHandle);
   return true;
}

//========================================================================//
//=================== INITIALIZE TRADE LOG ===============================//
//========================================================================//

bool InitTradeLog()
{
   tradeLogHandle = FileOpen(InpTradeLogFile, FILE_WRITE|FILE_CSV|FILE_ANSI, ',');
   if(tradeLogHandle == INVALID_HANDLE)
   {
      Print("Failed to create trade log: ", InpTradeLogFile);
      return false;
   }
   
   FileWrite(tradeLogHandle,
      "Timestamp", "Ticket", "Symbol", "Action", "Type", 
      "Lots", "EntryPrice", "SL", "TP",
      "EntryQuality", "EntryConfluence", "EntryZone", "EntryRegime", "EntryEntropy",
      "EntryMAFast", "EntryMASlow", "EntrySpread",
      "ExitPrice", "ExitReason", "Profit", "ProfitPercent", "Pips",
      "ExitQuality", "ExitConfluence", "HoldTimeBars",
      "MFE", "MAE", "MFEPercent", "MAEPercent", "MFE_Pips", "MAE_Pips",
      "RiskPercent", "RRatio",
      "EntryHour", "EntryDayOfWeek", "ExitHour"
   );
   
   FileClose(tradeLogHandle);
   return true;
}

//========================================================================//
//=================== v5.8: DRAW MA LINES (NEW) =========================//
//========================================================================//
// ✅ v5.8: NEW FUNCTION - Draw MA lines on chart using global buffers
//========================================================================//

void DrawMALines()
{
   if(!InpShowMALines)
      return;
   
   // Draw Entry MAs
   string nameFastEntry = "MA_Fast_Entry";
   string nameSlowEntry = "MA_Slow_Entry";
   
   ObjectCreate(0, nameFastEntry, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maFastEntry[1], 
                iTime(_Symbol, _Period, 0), g_maFastEntry[0]);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_COLOR, InpColorFastEntry);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_WIDTH, InpMALineWidth);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, nameFastEntry, OBJPROP_RAY_RIGHT, false);
   
   ObjectCreate(0, nameSlowEntry, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maSlowEntry[1], 
                iTime(_Symbol, _Period, 0), g_maSlowEntry[0]);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_COLOR, InpColorSlowEntry);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_WIDTH, InpMALineWidth);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(0, nameSlowEntry, OBJPROP_RAY_RIGHT, false);
   
   // Draw Exit MAs if enabled
   if(InpUseMAExit)
   {
      string nameFastExit = "MA_Fast_Exit";
      string nameSlowExit = "MA_Slow_Exit";
      
      ObjectCreate(0, nameFastExit, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maFastExit[1], 
                   iTime(_Symbol, _Period, 0), g_maFastExit[0]);
      ObjectSetInteger(0, nameFastExit, OBJPROP_COLOR, InpColorExit);
      ObjectSetInteger(0, nameFastExit, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, nameFastExit, OBJPROP_STYLE, STYLE_DOT);
      ObjectSetInteger(0, nameFastExit, OBJPROP_RAY_RIGHT, false);
      
      ObjectCreate(0, nameSlowExit, OBJ_TREND, 0, iTime(_Symbol, _Period, 1), g_maSlowExit[1], 
                   iTime(_Symbol, _Period, 0), g_maSlowExit[0]);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_COLOR, InpColorExit);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_WIDTH, 1);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_STYLE, STYLE_DASH);
      ObjectSetInteger(0, nameSlowExit, OBJPROP_RAY_RIGHT, false);
   }
}

//========================================================================//
//=================== UPDATE DISPLAY =====================================//
//========================================================================//

void UpdateDisplay(int signal, double quality, double confluence, 
                   double tradingZone, double volRegime, double entropy)
{
   // ✅ v5.8: Use global MA buffers for display
   string maEntryStatus = (g_maFastEntry[0] > g_maSlowEntry[0]) ? "BULLISH" : "BEARISH";
   string maExitStatus = InpUseMAExit ? 
      ((g_maFastExit[0] > g_maSlowExit[0]) ? "EXIT_ABOVE" : "EXIT_BELOW") : "N/A";
   
   string modeStr = "";
   if(!InpUsePhysics && !InpUseTickPhysicsIndicator)
      modeStr = "MA Crossover ONLY (Baseline)";
   else if(InpUsePhysics && InpUseTickPhysicsIndicator)
      modeStr = "MA Crossover + Physics Filters";
   else
      modeStr = "Hybrid Mode";
   
   string zoneStr = (tradingZone == 0) ? "BULL" :
                    (tradingZone == 1) ? "BEAR" :
                    (tradingZone == 2) ? "TRANS" : "AVOID";
   
   string signalStr = (signal == 1) ? "BUY SIGNAL" :
                      (signal == -1) ? "SELL SIGNAL" : "NO SIGNAL";
   
   string filterStatus = (InpUsePhysics) ? "ON" : "OFF";
   
   double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double dailyPnL = GetDailyPnL();
   
   Comment(StringFormat(
      "EA: %s v%s\n"
      "MODE: %-36s\n"
      "Entry: %-37s\n"
      "Exit:  %-37s\n"
      "Signal: %-37s\n"
      "Physics Filters: %-27s\n"
      "TickPhysics Ind: %-27s\n"
      "Entropy Filter: %-27s\n"
      "Zone Filter: %-27s\n"
      "Regime Filter: %-27s\n"
      "Session Filter: %-27s\n"
      "Daily Limits: %-27s\n"
      "Price: $%-28.2f\n"
      "Positions: %-2d / %-2d\n"
      "Daily P/L: %-7.2f%%\n"
      "Daily Trades: %-3d\n"
      "Consec Losses: %-2d\n"
      "Status: %-28s\n"
      "Quality: %-6.1f | Confluence: %-6.1f\n"
      "Zone: %-28s\n"
      "Entropy: %-7.2f %-20s\n",
      EA_NAME, EA_VERSION,
      modeStr,
      maEntryStatus,
      maExitStatus,
      signalStr,
      filterStatus,
      (InpUseTickPhysicsIndicator ? "ON" : "OFF"),
      (InpUseEntropyFilter ? "ON" : "OFF"),
      (InpRequireGreenZone ? "ON" : "OFF"),
      (InpTradeOnlyNormalRegime ? "ON" : "OFF"),
      (InpUseSessionFilter ? "ON" : "OFF"),
      (InpPauseOnLimits ? "ON" : "OFF"),
      currentPrice,
      CountPositions(), InpMaxPositions,
      dailyPnL,
      dailyTradeCount,
      consecutiveLosses,
      (dailyPaused ? "PAUSED" : "ACTIVE"),
      quality, confluence,
      zoneStr,
      entropy, 
      (entropy > InpMaxEntropy ? "(CHAOS)" : entropy > InpMaxEntropy * 0.7 ? "(NOISY)" : "(CLEAN)")
   ));
}

//============================= CHUNK 8: MAIN EVENT FUNCTIONS ============//

//========================================================================//
//=================== OnInit() ===========================================//
//========================================================================//

int OnInit()
{
   Print("Initializing ", EA_NAME, " v", EA_VERSION);
   Print("-----------------------------");

   // Create MA indicators (unified for entry AND exit)
   maFastEntry_Handle = iMA(_Symbol, _Period, InpMAFast, 0, InpMAMethod, InpMAPrice);
   maSlowEntry_Handle = iMA(_Symbol, _Period, InpMASlow, 0, InpMAMethod, InpMAPrice);

   if(maFastEntry_Handle == INVALID_HANDLE || maSlowEntry_Handle == INVALID_HANDLE)
   {
      Print("ERROR: Failed to create Entry MA indicators");
      return INIT_FAILED;
   }
   
   if(InpUseMAExit)
   {
      // Use SAME MA parameters for exit to ensure deterministic binary signals
      maFastExit_Handle = iMA(_Symbol, _Period, InpMAFast, 0, InpMAMethod, InpMAPrice);
      maSlowExit_Handle = iMA(_Symbol, _Period, InpMASlow, 0, InpMAMethod, InpMAPrice);
      
      if(maFastExit_Handle == INVALID_HANDLE || maSlowExit_Handle == INVALID_HANDLE)
      {
         Print("ERROR: Failed to create Exit MA indicators");
         return INIT_FAILED;
      }
   }
   
   // ✅ v5.8: Initialize global MA buffer arrays
   ArraySetAsSeries(g_maFastEntry, true);
   ArraySetAsSeries(g_maSlowEntry, true);
   ArraySetAsSeries(g_maFastExit, true);
   ArraySetAsSeries(g_maSlowExit, true);
   
   if(InpUseTickPhysicsIndicator)
   {
      indicatorHandle = iCustom(_Symbol, _Period, InpIndicatorName);
      
      if(indicatorHandle == INVALID_HANDLE)
      {
         Print("WARNING: TickPhysics indicator not found!");
         Print("   Indicator name: ", InpIndicatorName);
         Print("   Physics filters will be disabled");
      }
      else
      {
         Print("TickPhysics indicator loaded successfully");
      }
   }
   
   if(InpEnableSignalLog)
   {
      if(!InitSignalLog())
      {
         Print("ERROR: Failed to initialize signal log");
         return INIT_FAILED;
      }
      Print("Signal logging initialized");
   }
   
   if(InpEnableTradeLog)
   {
      if(!InitTradeLog())
      {
         Print("ERROR: Failed to initialize trade log");
         return INIT_FAILED;
      }
      Print("Trade logging initialized");
   }
   
   dailyStartBalance = AccountInfoDouble(ACCOUNT_EQUITY);
   lastDayCheck = 0;

   Print("-----------------------------");
   Print("EA CONFIGURATION:");
   Print("   MA (Entry & Exit): ", InpMAFast, "/", InpMASlow, " [UNIFIED for binary signals]");
   Print("   Risk: ", InpRiskPerTradePercent, "% | SL: ", InpStopLossPercent, "% | TP: ", InpTakeProfitPercent, "%");
   Print("   Physics: ", (InpUsePhysics ? "ENABLED" : "DISABLED"));
   Print("   Indicator: ", (InpUseTickPhysicsIndicator ? "ENABLED" : "DISABLED"));
   Print("   Max Spread: ", InpMaxSpread, " points");
   Print("-----------------------------");
   Print("EA initialized successfully - Ready to trade!");
   Print("-----------------------------");

   return INIT_SUCCEEDED;
}

//========================================================================//
//=================== OnDeinit() =========================================//
//========================================================================//

void OnDeinit(const int reason)
{
   Print("Shutting down ", EA_NAME, " v", EA_VERSION);
   Print("   Reason: ", reason);

   if(maFastEntry_Handle != INVALID_HANDLE) IndicatorRelease(maFastEntry_Handle);
   if(maSlowEntry_Handle != INVALID_HANDLE) IndicatorRelease(maSlowEntry_Handle);
   if(maFastExit_Handle != INVALID_HANDLE) IndicatorRelease(maFastExit_Handle);
   if(maSlowExit_Handle != INVALID_HANDLE) IndicatorRelease(maSlowExit_Handle);
   if(indicatorHandle != INVALID_HANDLE) IndicatorRelease(indicatorHandle);

   // Clean up chart objects
   ObjectsDeleteAll(0, "MA_");

   Print("   Total daily trades: ", dailyTradeCount);
   Print("   Daily P/L: ", GetDailyPnL(), "%");

   Print("-----------------------------");
   Print("EA shutdown complete");
   Print("-----------------------------");

   Comment("");
}

//========================================================================//
//=================== OnTick() - v5.8 WITH GLOBAL BUFFERS ===============//
//========================================================================//
// ✅ v5.8: MA buffers updated ONCE per bar, then shared globally
//========================================================================//

void OnTick()
{
   lastTickTime = TimeCurrent();

   datetime currentBarTime = iTime(_Symbol, _Period, 0);
   if(currentBarTime == lastBarTime)
      return;
   lastBarTime = currentBarTime;

   CheckDailyReset();

   if(dailyPaused)
   {
      Comment("EA PAUSED - Daily limits reached\n",
              "Daily P/L: ", DoubleToString(GetDailyPnL(), 2), "%\n",
              "Resets at midnight");
      return;
   }
   
   if(InpUseSessionFilter && !IsWithinSession())
      return;
   
   // ========================================================================
   // ✅ v5.8: STEP 1 - UPDATE GLOBAL MA BUFFERS (ONCE PER BAR)
   // This is the KEY FIX - all functions now use the same synchronized data
   // ========================================================================
   if(!UpdateMABuffers())
   {
      Print("ERROR: Failed to update MA buffers");
      return;
   }
   
   // ========================================================================
   // STEP 2: Get the current signal (now uses global buffers)
   // ========================================================================
   int signal = GetMACrossoverSignal();
   
   if(InpEnableDebug)
      Print("DEBUG: OnTick() START - Signal=", signal);
   
   double quality = 0.0, confluence = 0.0, momentum = 0.0;
   double tradingZone = 0.0, volRegime = 0.0, entropy = 0.0;
   
   if(InpUsePhysics && InpUseTickPhysicsIndicator)
   {
      double qualityBuf[1], confluenceBuf[1], momentumBuf[1], zoneBuf[1], regimeBuf[1], entropyBuf[1];
      if(CopyBuffer(indicatorHandle, BUFFER_QUALITY, 0, 1, qualityBuf) > 0)
         quality = qualityBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_CONFLUENCE, 0, 1, confluenceBuf) > 0)
         confluence = confluenceBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_MOMENTUM, 0, 1, momentumBuf) > 0)
         momentum = momentumBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_TRADING_ZONE, 0, 1, zoneBuf) > 0)
         tradingZone = zoneBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_VOL_REGIME, 0, 1, regimeBuf) > 0)
         volRegime = regimeBuf[0];
      if(CopyBuffer(indicatorHandle, BUFFER_ENTROPY, 0, 1, entropyBuf) > 0)
         entropy = entropyBuf[0];
   }
   
   string rejectReason = "";
   bool physicsPass = CheckPhysicsFilters(signal, quality, confluence, tradingZone, 
                                          volRegime, entropy, rejectReason);
   
   if(InpEnableSignalLog && signal != 0)
   {
      LogSignal(signal, quality, confluence, momentum, tradingZone, volRegime, entropy, 
                physicsPass, rejectReason);
   }
   
   // ========================================================================
   // STEP 3: MANAGE POSITIONS FIRST (exits before new entries)
   // ========================================================================
   if(InpEnableDebug)
      Print("DEBUG: Calling ManagePositions()");
   
   ManagePositions();
   
   // ========================================================================
   // STEP 4: After positions managed, attempt entry based on signal
   // ========================================================================
   // ✅ v6.0: Recount positions AFTER ManagePositions() has closed old ones
   int currentPositions = CountPositions();
   
   if(InpEnableDebug)
      Print("DEBUG: After ManagePositions() - Positions=", currentPositions, " | ClosedThisBar=", positionClosedThisBar);
   
   if(signal != 0)
   {
      ENUM_ORDER_TYPE orderType = (signal == 1) ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
      
      if(InpEnableDebug)
      {
         Print("   Signal Direction: ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"));
         Print("   Current Positions: ", currentPositions, "/", InpMaxPositions);
      }
      
      // ✅ v6.0 KEY FIX: Allow entry if we just closed a position (close->reverse)
      // Even if currentPositions still shows 1 due to MT5 delay
      bool allowEntry = (currentPositions < InpMaxPositions) || positionClosedThisBar;
      
      if(!allowEntry)
      {
         if(InpEnableDebug)
            Print("DEBUG: Entry blocked - Max positions (", currentPositions, "/", InpMaxPositions, ")");
      }
      else if(consecutiveLosses >= InpMaxConsecutiveLosses)
      {
         if(InpEnableDebug)
            Print("DEBUG: Entry blocked - Max losses (", consecutiveLosses, "/", InpMaxConsecutiveLosses, ")");
      }
      else if(!physicsPass)
      {
         if(InpEnableDebug)
            Print("DEBUG: Entry blocked by physics: ", rejectReason);
      }
      else
      {
         if(InpEnableDebug)
            Print("DEBUG: Opening ", (orderType == ORDER_TYPE_BUY ? "BUY" : "SELL"));
         
         if(OpenPosition(orderType))
         {
            dailyTradeCount++;
         }
      }
   }
   
   // ========================================================================
   // STEP 5: Draw MA lines on chart (using global buffers)
   // ========================================================================
   DrawMALines();
   
   UpdateDisplay(signal, quality, confluence, tradingZone, volRegime, entropy);
}

//========================================================================//
//=================== END OF v6.0 EA =====================================//
//========================================================================//

/*
  TickPhysics EA v6.0 - UNIFIED MA BASELINE (Simple, Deterministic, Binary)
  
  KEY FEATURES:
  - ONE MA pair (10/30 EMA) for both entry AND exit
  - Every crossover closes opposite position and opens new position
  - Deterministic, repeatable binary win/loss signals
  - Perfect for CSV export and Python self-learning
  
  GLOBAL SYNCHRONIZATION (from v5.8):
  - Global MA buffers updated once per bar in UpdateMABuffers()
  - All functions reference same synchronized data
  - No race conditions or timing issues
  
  ROBUSTNESS:
  - PositionSelectByTicket() before all PositionGet* calls
  - ASCII-only logging (no Unicode/emoji issues)
  - Clean compile with no warnings
  
  See repository docs for full changelog and testing checklist.
*/
